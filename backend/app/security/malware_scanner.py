"""
Malware scanning capabilities using multiple detection methods.
"""

import hashlib
import math
import subprocess
import tempfile
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Set

from ..core.config import get_settings
from ..core.logging import get_logger
from ..monitoring.metrics_collector import get_metrics_collector

logger = get_logger(__name__)
settings = get_settings()
metrics_collector = get_metrics_collector()


class ScanStatus(Enum):
    """Malware scan status."""
    CLEAN = "clean"
    INFECTED = "infected"
    SUSPICIOUS = "suspicious"
    ERROR = "error"
    SKIPPED = "skipped"


@dataclass
class ScanResult:
    """Result of malware scan."""
    status: ScanStatus
    threats_found: List[str]
    scan_engine: str
    scan_time_seconds: float
    file_hash: str
    metadata: Dict[str, any]


class MalwareScanner:
    """Malware scanner with multiple detection engines."""
    
    # Known malicious file hashes (example - in production, use threat intelligence feeds)
    KNOWN_MALICIOUS_HASHES = {
        # Add known malicious file hashes here
        "d41d8cd98f00b204e9800998ecf8427e",  # Example hash
    }
    
    # Suspicious file patterns
    SUSPICIOUS_PATTERNS = [
        # Executable patterns
        b"MZ",  # PE executable header
        b"\x7fELF",  # ELF executable header
        b"\xca\xfe\xba\xbe",  # Mach-O executable header
        b"\xfe\xed\xfa\xce",  # Mach-O 32-bit
        b"\xce\xfa\xed\xfe",  # Mach-O 32-bit reverse
        
        # Script patterns
        b"#!/bin/sh",
        b"#!/bin/bash",
        b"#!/usr/bin/env",
        b"@echo off",
        b"powershell",
        b"cmd.exe",
        b"wscript",
        b"cscript",
        
        # Suspicious strings
        b"eval(",
        b"exec(",
        b"system(",
        b"shell_exec(",
        b"passthru(",
        b"base64_decode(",
        b"CreateObject(",
        b"WScript.Shell",
        b"ActiveXObject",
        
        # Network patterns
        b"http://",
        b"https://",
        b"ftp://",
        b"tcp://",
        b"udp://",
        b"socket(",
        b"connect(",
        b"bind(",
        b"listen(",
        
        # Crypto/encoding patterns
        b"base64",
        b"atob(",
        b"btoa(",
        b"unescape(",
        b"decodeURIComponent(",
        
        # Registry manipulation (Windows)
        b"HKEY_",
        b"RegWrite",
        b"RegRead",
        b"RegDelete",
        
        # File system manipulation
        b"CreateFile",
        b"WriteFile",
        b"DeleteFile",
        b"MoveFile",
        b"CopyFile",
        
        # Process manipulation
        b"CreateProcess",
        b"TerminateProcess",
        b"OpenProcess",
        b"VirtualAlloc",
        b"VirtualProtect",
        
        # Anti-analysis techniques
        b"IsDebuggerPresent",
        b"CheckRemoteDebuggerPresent",
        b"GetTickCount",
        b"Sleep(",
        b"delay(",
        
        # Persistence mechanisms
        b"autorun",
        b"startup",
        b"scheduled task",
        b"service install",
        b"registry run",
    ]
    
    def __init__(self):
        """Initialize malware scanner."""
        self.clamav_available = self._check_clamav_availability()
        
    def _check_clamav_availability(self) -> bool:
        """Check if ClamAV is available."""
        try:
            result = subprocess.run(
                ["clamscan", "--version"], 
                capture_output=True, 
                text=True, 
                timeout=5
            )
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError, subprocess.SubprocessError):
            logger.warning("ClamAV not available, using built-in scanning only")
            return False
    
    async def scan_file(self, file_content: bytes, filename: str) -> ScanResult:
        """
        Scan file for malware using available engines.
        
        Args:
            file_content: Raw file content
            filename: Original filename
            
        Returns:
            ScanResult with scan details
        """
        import time
        start_time = time.time()
        
        logger.info(f"Starting malware scan for file: {filename}")
        
        # Generate file hash
        file_hash = hashlib.sha256(file_content).hexdigest()
        
        # Initialize result
        result = ScanResult(
            status=ScanStatus.CLEAN,
            threats_found=[],
            scan_engine="built-in",
            scan_time_seconds=0.0,
            file_hash=file_hash,
            metadata={"filename": filename, "file_size": len(file_content)}
        )
        
        try:
            # Check against known malicious hashes
            hash_threats = self._check_malicious_hashes(file_hash)
            if hash_threats:
                result.threats_found.extend(hash_threats)
                result.status = ScanStatus.INFECTED
            
            # Pattern-based scanning
            pattern_threats = self._scan_patterns(file_content)
            if pattern_threats:
                result.threats_found.extend(pattern_threats)
                if result.status == ScanStatus.CLEAN:
                    result.status = ScanStatus.SUSPICIOUS
            
            # Heuristic analysis
            heuristic_threats = self._heuristic_analysis(file_content, filename)
            if heuristic_threats:
                result.threats_found.extend(heuristic_threats)
                if result.status == ScanStatus.CLEAN:
                    result.status = ScanStatus.SUSPICIOUS
            
            # ClamAV scanning if available
            if self.clamav_available:
                clamav_result = await self._scan_with_clamav(file_content, filename)
                if clamav_result.status != ScanStatus.CLEAN:
                    result.threats_found.extend(clamav_result.threats_found)
                    result.status = clamav_result.status
                    result.scan_engine = "clamav+built-in"
            
            # Calculate scan time
            result.scan_time_seconds = time.time() - start_time
            
            # Record malware scan metrics
            metrics_collector.record_malware_scan(
                result=result.status.value,
                engine=result.scan_engine
            )
            
            # Record security events if threats found
            if result.threats_found:
                severity = "high" if result.status == ScanStatus.INFECTED else "medium"
                metrics_collector.record_security_event(
                    event_type="malware_detected",
                    severity=severity
                )
            
            logger.info(f"Malware scan completed for {filename}: {result.status.value}")
            return result
            
        except Exception as e:
            logger.error(f"Error during malware scan: {e}", exc_info=True)
            result.status = ScanStatus.ERROR
            result.threats_found.append(f"Scan error: {str(e)}")
            result.scan_time_seconds = time.time() - start_time
            
            # Record failed scan metrics
            metrics_collector.record_malware_scan(
                result="error",
                engine="built-in"
            )
            
            metrics_collector.record_security_event(
                event_type="scan_error",
                severity="medium"
            )
            
            return result
    
    def _check_malicious_hashes(self, file_hash: str) -> List[str]:
        """Check file hash against known malicious hashes."""
        threats = []
        
        if file_hash in self.KNOWN_MALICIOUS_HASHES:
            threats.append(f"Known malicious file hash: {file_hash}")
        
        return threats
    
    def _scan_patterns(self, file_content: bytes) -> List[str]:
        """Scan for suspicious patterns in file content."""
        threats = []
        
        # Convert to lowercase for case-insensitive matching
        content_lower = file_content.lower()
        
        for pattern in self.SUSPICIOUS_PATTERNS:
            if pattern in content_lower:
                threats.append(f"Suspicious pattern detected: {pattern.decode('utf-8', errors='ignore')}")
        
        return threats
    
    def _heuristic_analysis(self, file_content: bytes, filename: str) -> List[str]:
        """Perform heuristic analysis for suspicious behavior."""
        threats = []
        
        # Check entropy (high entropy might indicate encryption/packing)
        entropy = self._calculate_entropy(file_content)
        if entropy > 7.5:  # High entropy threshold
            threats.append(f"High entropy detected: {entropy:.2f} (possible packed/encrypted content)")
        
        # Check for excessive repetition (possible padding attack)
        if self._has_excessive_repetition(file_content):
            threats.append("Excessive repetition detected (possible padding attack)")
        
        # Check for suspicious file size patterns
        file_size = len(file_content)
        if file_size == 0:
            threats.append("Empty file detected")
        elif file_size > 100 * 1024 * 1024:  # 100MB
            threats.append(f"Unusually large file: {file_size} bytes")
        
        # Check for embedded executables
        if self._has_embedded_executable(file_content):
            threats.append("Embedded executable detected")
        
        # Check for suspicious metadata
        if self._has_suspicious_metadata(filename):
            threats.append("Suspicious filename patterns detected")
        
        # Advanced behavioral analysis
        advanced_threats = self._advanced_behavioral_analysis(file_content, filename)
        threats.extend(advanced_threats)
        
        return threats
    
    def _advanced_behavioral_analysis(self, file_content: bytes, filename: str) -> List[str]:
        """Perform advanced behavioral analysis using YARA-like rules."""
        threats = []
        
        # Check for polyglot files (files that are valid in multiple formats)
        if self._is_polyglot_file(file_content):
            threats.append("Polyglot file detected (valid in multiple formats)")
        
        # Check for steganography indicators
        if self._has_steganography_indicators(file_content):
            threats.append("Possible steganography detected")
        
        # Check for code injection patterns
        injection_patterns = self._detect_code_injection_patterns(file_content)
        threats.extend(injection_patterns)
        
        # Check for anti-VM/sandbox techniques
        if self._has_anti_analysis_techniques(file_content):
            threats.append("Anti-analysis techniques detected")
        
        # Check for persistence mechanisms
        persistence_threats = self._detect_persistence_mechanisms(file_content)
        threats.extend(persistence_threats)
        
        # Check for data exfiltration patterns
        exfiltration_threats = self._detect_exfiltration_patterns(file_content)
        threats.extend(exfiltration_threats)
        
        # Check for lateral movement indicators
        if self._has_lateral_movement_indicators(file_content):
            threats.append("Lateral movement techniques detected")
        
        return threats
    
    def _is_polyglot_file(self, file_content: bytes) -> bool:
        """Check if file is a polyglot (valid in multiple formats)."""
        if len(file_content) < 100:
            return False
        
        # Check for multiple file format headers
        headers_found = 0
        
        # Common file headers
        file_headers = [
            b"%PDF-",  # PDF
            b"PK\x03\x04",  # ZIP/Office
            b"\xff\xd8\xff",  # JPEG
            b"\x89PNG",  # PNG
            b"GIF8",  # GIF
            b"MZ",  # PE executable
            b"\x7fELF",  # ELF
            b"<!DOCTYPE",  # HTML
            b"<html",  # HTML
            b"<?xml",  # XML
        ]
        
        for header in file_headers:
            if header in file_content:
                headers_found += 1
        
        return headers_found >= 2
    
    def _has_steganography_indicators(self, file_content: bytes) -> bool:
        """Check for steganography indicators."""
        # Look for unusual patterns in image-like files
        if len(file_content) < 1000:
            return False
        
        # Check for hidden data patterns
        # Look for LSB steganography indicators
        if b"\xff\xd8\xff" in file_content[:10]:  # JPEG
            # Check for unusual comment sections
            if b"\xff\xfe" in file_content:  # Comment marker
                return True
        
        # Check for unusual entropy distribution
        chunks = [file_content[i:i+1024] for i in range(0, len(file_content), 1024)]
        entropies = [self._calculate_entropy(chunk) for chunk in chunks if len(chunk) > 100]
        
        if len(entropies) > 5:
            entropy_variance = sum((e - sum(entropies)/len(entropies))**2 for e in entropies) / len(entropies)
            if entropy_variance > 2.0:  # High variance in entropy
                return True
        
        return False
    
    def _detect_code_injection_patterns(self, file_content: bytes) -> List[str]:
        """Detect code injection patterns."""
        threats = []
        
        # DLL injection patterns
        dll_injection_patterns = [
            b"LoadLibrary",
            b"GetProcAddress",
            b"VirtualAllocEx",
            b"WriteProcessMemory",
            b"CreateRemoteThread",
            b"SetWindowsHookEx",
        ]
        
        dll_pattern_count = sum(1 for pattern in dll_injection_patterns if pattern in file_content)
        if dll_pattern_count >= 3:
            threats.append(f"DLL injection patterns detected ({dll_pattern_count} indicators)")
        
        # Process hollowing patterns
        hollowing_patterns = [
            b"NtUnmapViewOfSection",
            b"VirtualAllocEx",
            b"WriteProcessMemory",
            b"SetThreadContext",
            b"ResumeThread",
        ]
        
        hollowing_pattern_count = sum(1 for pattern in hollowing_patterns if pattern in file_content)
        if hollowing_pattern_count >= 3:
            threats.append(f"Process hollowing patterns detected ({hollowing_pattern_count} indicators)")
        
        # Reflective DLL loading
        if b"ReflectiveLoader" in file_content or (b"DllMain" in file_content and b"GetProcAddress" in file_content):
            threats.append("Reflective DLL loading patterns detected")
        
        return threats
    
    def _has_anti_analysis_techniques(self, file_content: bytes) -> bool:
        """Check for anti-analysis techniques."""
        anti_analysis_patterns = [
            b"IsDebuggerPresent",
            b"CheckRemoteDebuggerPresent",
            b"NtQueryInformationProcess",
            b"OutputDebugString",
            b"GetTickCount",
            b"QueryPerformanceCounter",
            b"cpuid",
            b"rdtsc",
            b"VirtualBox",
            b"VMware",
            b"QEMU",
            b"Xen",
            b"Sandbox",
            b"Cuckoo",
            b"Anubis",
        ]
        
        pattern_count = sum(1 for pattern in anti_analysis_patterns if pattern in file_content)
        return pattern_count >= 2
    
    def _detect_persistence_mechanisms(self, file_content: bytes) -> List[str]:
        """Detect persistence mechanisms."""
        threats = []
        
        # Registry persistence
        registry_patterns = [
            b"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
            b"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
            b"SYSTEM\\CurrentControlSet\\Services",
            b"RegSetValueEx",
            b"RegCreateKeyEx",
        ]
        
        registry_count = sum(1 for pattern in registry_patterns if pattern in file_content)
        if registry_count >= 2:
            threats.append(f"Registry persistence mechanisms detected ({registry_count} indicators)")
        
        # File system persistence
        if b"autorun.inf" in file_content or b"desktop.ini" in file_content:
            threats.append("File system persistence mechanisms detected")
        
        # Service persistence
        service_patterns = [b"CreateService", b"OpenSCManager", b"StartService"]
        service_count = sum(1 for pattern in service_patterns if pattern in file_content)
        if service_count >= 2:
            threats.append("Service persistence mechanisms detected")
        
        # Scheduled task persistence
        if b"schtasks" in file_content or b"Task Scheduler" in file_content:
            threats.append("Scheduled task persistence detected")
        
        return threats
    
    def _detect_exfiltration_patterns(self, file_content: bytes) -> List[str]:
        """Detect data exfiltration patterns."""
        threats = []
        
        # Network exfiltration
        network_patterns = [
            b"HttpSendRequest",
            b"InternetOpen",
            b"URLDownloadToFile",
            b"WinHttpOpen",
            b"send(",
            b"recv(",
            b"FTP",
            b"SMTP",
        ]
        
        network_count = sum(1 for pattern in network_patterns if pattern in file_content)
        if network_count >= 3:
            threats.append(f"Network exfiltration patterns detected ({network_count} indicators)")
        
        # File exfiltration
        file_patterns = [
            b"CopyFile",
            b"MoveFile",
            b"CreateFile",
            b"WriteFile",
            b"ReadFile",
        ]
        
        file_count = sum(1 for pattern in file_patterns if pattern in file_content)
        if file_count >= 4:
            threats.append("File manipulation patterns detected")
        
        # Encryption before exfiltration
        crypto_patterns = [
            b"CryptAcquireContext",
            b"CryptEncrypt",
            b"CryptCreateHash",
            b"AES",
            b"RSA",
            b"base64",
        ]
        
        crypto_count = sum(1 for pattern in crypto_patterns if pattern in file_content)
        if crypto_count >= 2 and network_count >= 1:
            threats.append("Encrypted data exfiltration patterns detected")
        
        return threats
    
    def _has_lateral_movement_indicators(self, file_content: bytes) -> bool:
        """Check for lateral movement indicators."""
        lateral_patterns = [
            b"PsExec",
            b"WMI",
            b"WinRM",
            b"PowerShell",
            b"net use",
            b"net share",
            b"SMB",
            b"RDP",
            b"SSH",
            b"Telnet",
            b"NetUserEnum",
            b"NetShareEnum",
            b"NetSessionEnum",
        ]
        
        pattern_count = sum(1 for pattern in lateral_patterns if pattern in file_content)
        return pattern_count >= 3
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data."""
        if not data:
            return 0.0
        
        # Count byte frequencies
        byte_counts = [0] * 256
        for byte in data:
            byte_counts[byte] += 1
        
        # Calculate entropy
        entropy = 0.0
        data_len = len(data)
        
        for count in byte_counts:
            if count > 0:
                probability = count / data_len
                entropy -= probability * math.log2(probability)
        
        return entropy
    
    def _has_excessive_repetition(self, file_content: bytes) -> bool:
        """Check for excessive repetition in file content."""
        if len(file_content) < 1000:
            return False
        
        # Check for repeated patterns
        sample_size = min(1000, len(file_content))
        sample = file_content[:sample_size]
        
        # Count most common byte
        byte_counts = {}
        for byte in sample:
            byte_counts[byte] = byte_counts.get(byte, 0) + 1
        
        max_count = max(byte_counts.values())
        repetition_ratio = max_count / sample_size
        
        return repetition_ratio > 0.8  # 80% repetition threshold
    
    def _has_embedded_executable(self, file_content: bytes) -> bool:
        """Check for embedded executable content."""
        # Look for executable headers within the file
        executable_headers = [b"MZ", b"\x7fELF", b"\xca\xfe\xba\xbe"]
        
        for header in executable_headers:
            # Check if header appears not at the beginning (embedded)
            pos = file_content.find(header, 100)  # Skip first 100 bytes
            if pos != -1:
                return True
        
        return False
    
    def _has_suspicious_metadata(self, filename: str) -> bool:
        """Check for suspicious filename patterns."""
        suspicious_patterns = [
            "temp", "tmp", "cache", "system32", "windows", "program files",
            "autorun", "setup", "install", "update", "patch", "crack",
            "keygen", "serial", "license", "activation"
        ]
        
        filename_lower = filename.lower()
        return any(pattern in filename_lower for pattern in suspicious_patterns)
    
    async def _scan_with_clamav(self, file_content: bytes, filename: str) -> ScanResult:
        """Scan file using ClamAV engine."""
        result = ScanResult(
            status=ScanStatus.CLEAN,
            threats_found=[],
            scan_engine="clamav",
            scan_time_seconds=0.0,
            file_hash=hashlib.sha256(file_content).hexdigest(),
            metadata={"filename": filename}
        )
        
        if not self.clamav_available:
            result.status = ScanStatus.SKIPPED
            return result
        
        import time
        start_time = time.time()
        
        try:
            # Write file to temporary location for scanning
            with tempfile.NamedTemporaryFile(delete=False) as temp_file:
                temp_file.write(file_content)
                temp_file_path = temp_file.name
            
            try:
                # Run ClamAV scan
                cmd = ["clamscan", "--no-summary", "--infected", temp_file_path]
                process = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=30  # 30 second timeout
                )
                
                result.scan_time_seconds = time.time() - start_time
                
                if process.returncode == 0:
                    # Clean file
                    result.status = ScanStatus.CLEAN
                elif process.returncode == 1:
                    # Infected file
                    result.status = ScanStatus.INFECTED
                    # Parse threats from output
                    for line in process.stdout.split('\n'):
                        if 'FOUND' in line:
                            threat = line.split(':')[-1].strip()
                            result.threats_found.append(f"ClamAV: {threat}")
                else:
                    # Error occurred
                    result.status = ScanStatus.ERROR
                    result.threats_found.append(f"ClamAV scan error: {process.stderr}")
                
            finally:
                # Clean up temporary file
                Path(temp_file_path).unlink(missing_ok=True)
                
        except subprocess.TimeoutExpired:
            result.status = ScanStatus.ERROR
            result.threats_found.append("ClamAV scan timeout")
            result.scan_time_seconds = time.time() - start_time
        except Exception as e:
            result.status = ScanStatus.ERROR
            result.threats_found.append(f"ClamAV scan error: {str(e)}")
            result.scan_time_seconds = time.time() - start_time
        
        return result
    
    def update_threat_database(self) -> bool:
        """Update malware threat database."""
        success = True
        
        # Update ClamAV database if available
        if self.clamav_available:
            try:
                result = subprocess.run(
                    ["freshclam"],
                    capture_output=True,
                    text=True,
                    timeout=300  # 5 minute timeout
                )
                
                if result.returncode == 0:
                    logger.info("ClamAV database updated successfully")
                else:
                    logger.error(f"Failed to update ClamAV database: {result.stderr}")
                    success = False
                    
            except Exception as e:
                logger.error(f"Error updating ClamAV database: {e}")
                success = False
        else:
            logger.warning("ClamAV not available, skipping ClamAV database update")
        
        # Update built-in threat intelligence
        try:
            self._update_threat_intelligence()
            logger.info("Built-in threat intelligence updated successfully")
        except Exception as e:
            logger.error(f"Error updating threat intelligence: {e}")
            success = False
        
        return success
    
    def _update_threat_intelligence(self) -> None:
        """Update built-in threat intelligence from various sources."""
        # In a production environment, this would fetch from threat intelligence feeds
        # For now, we'll update our known malicious hashes with common test hashes
        
        # EICAR test file hash (standard antivirus test file)
        eicar_hash = "275a021bbfb6489e54d471899f7db9d1663fc695ec2fe2a2c4538aabf651fd0f"
        
        # Add to known malicious hashes
        self.KNOWN_MALICIOUS_HASHES.add(eicar_hash)
        
        # Update suspicious patterns with latest IOCs (Indicators of Compromise)
        new_patterns = [
            # Recent malware families
            b"Emotet",
            b"TrickBot",
            b"Ryuk",
            b"Conti",
            b"Maze",
            b"REvil",
            b"DarkSide",
            b"BlackMatter",
            
            # APT indicators
            b"Cobalt Strike",
            b"Metasploit",
            b"Empire",
            b"PowerSploit",
            
            # Cryptocurrency miners
            b"xmrig",
            b"cpuminer",
            b"ccminer",
            b"ethminer",
            
            # Remote access tools
            b"TeamViewer",
            b"AnyDesk",
            b"Chrome Remote Desktop",
            b"LogMeIn",
            
            # Suspicious domains (simplified check)
            b".tk",
            b".ml",
            b".ga",
            b".cf",
            b"bit.ly",
            b"tinyurl",
            b"t.co",
        ]
        
        # Add new patterns to existing ones
        self.SUSPICIOUS_PATTERNS.extend(new_patterns)
        
        logger.info(f"Updated threat intelligence with {len(new_patterns)} new patterns")
    
    def get_threat_intelligence_info(self) -> Dict[str, any]:
        """Get information about current threat intelligence."""
        return {
            "known_malicious_hashes": len(self.KNOWN_MALICIOUS_HASHES),
            "suspicious_patterns": len(self.SUSPICIOUS_PATTERNS),
            "last_updated": "manual_update",  # In production, track actual update times
            "sources": ["built-in", "clamav" if self.clamav_available else None],
            "version": "1.0.0"
        }
    
    def get_scanner_info(self) -> Dict[str, any]:
        """Get information about available scanners."""
        info = {
            "built_in_scanner": True,
            "clamav_available": self.clamav_available,
            "supported_engines": ["built-in"]
        }
        
        if self.clamav_available:
            info["supported_engines"].append("clamav")
            
            try:
                # Get ClamAV version
                result = subprocess.run(
                    ["clamscan", "--version"],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                if result.returncode == 0:
                    info["clamav_version"] = result.stdout.strip()
            except Exception:
                pass
        
        return info