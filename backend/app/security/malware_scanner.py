"""
Enhanced malware scanning capabilities with dynamic threat intelligence integration.
"""

import asyncio
import hashlib
import math
import subprocess
import tempfile
import time
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import ClassVar, Dict, List, Optional, Union

import aiohttp

from ..core.cache import cache_service
from ..core.config import get_settings
from ..core.logging import get_logger
from ..monitoring.metrics_collector import get_metrics_collector

# Initialize services
logger = get_logger(__name__)
settings = get_settings()
metrics_collector = get_metrics_collector()
cache_manager = cache_service

# Constants
THREAT_INTEL_CACHE_TTL = 3600  # 1 hour
THREAT_UPDATE_INTERVAL = 300  # 5 minutes
MIN_CONFIDENCE_SCORE = 0.7  # Minimum confidence score for threat intelligence

logger = get_logger(__name__)
settings = get_settings()
metrics_collector = get_metrics_collector()


class ScanStatus(Enum):
	"""Malware scan status."""

	CLEAN = "clean"
	INFECTED = "infected"
	SUSPICIOUS = "suspicious"
	ERROR = "error"
	SKIPPED = "skipped"


@dataclass
class ThreatIntelligence:
	"""Dynamic threat intelligence data."""

	hash: str
	threat_type: str
	confidence_score: float
	first_seen: datetime
	last_seen: datetime
	source: str
	additional_info: Optional[Dict[str, any]] = None


@dataclass
class ScanResult:
	"""Enhanced result of malware scan."""

	status: ScanStatus
	threats_found: List[str]
	scan_engine: str
	scan_time_seconds: float
	file_hash: str
	threat_intel: Optional[ThreatIntelligence] = None
	metadata: Dict[str, any] = None


class ThreatIntelligenceManager:
	"""Manager for dynamic threat intelligence feeds."""

	def __init__(self):
		"""Initialize threat intelligence manager."""
		self.api_keys = {
			"virustotal": settings.virustotal_api_key,
			"alienvault": settings.alienvault_api_key,
			"threatfox": settings.threatfox_api_key,
		}
		self.last_update = datetime.min
		self.known_threats: Dict[str, ThreatIntelligence] = {}

	async def initialize(self):
		"""Initialize threat intelligence feeds."""
		await self.update_threat_intelligence()

	async def update_threat_intelligence(self) -> None:
		"""Update threat intelligence data from multiple sources."""
		if (datetime.now() - self.last_update).total_seconds() < THREAT_UPDATE_INTERVAL:
			return

		try:
			async with aiohttp.ClientSession() as session:
				tasks = [self._update_virustotal(session), self._update_alienvault(session), self._update_threatfox(session)]
				await asyncio.gather(*tasks)

			self.last_update = datetime.now()
			await cache_manager.async_set("threat_intelligence", self.known_threats, THREAT_INTEL_CACHE_TTL)

		except Exception as e:
			logger.error(f"Error updating threat intelligence: {e!s}")

	async def _update_virustotal(self, session: aiohttp.ClientSession) -> None:
		"""Update threat data from VirusTotal."""
		if not self.api_keys["virustotal"]:
			return

		try:
			url = "https://www.virustotal.com/vtapi/v3/intelligence/hunting/notifications"
			headers = {"x-apikey": self.api_keys["virustotal"]}

			async with session.get(url, headers=headers) as response:
				if response.status == 200:
					data = await response.json()
					for notification in data.get("data", []):
						attributes = notification.get("attributes", {})
						if attributes.get("rule_category") == "malicious":
							self._add_threat_intel(
								hash=attributes.get("sha256"),
								threat_type=attributes.get("rule_name"),
								confidence_score=attributes.get("confidence", 0.0),
								first_seen=datetime.fromisoformat(attributes.get("date")),
								last_seen=datetime.now(),
								source="virustotal",
								additional_info={
									"malware_family": attributes.get("malware_family"),
									"detection_ratio": attributes.get("detection_ratio"),
								},
							)

		except Exception as e:
			logger.error(f"Error updating VirusTotal data: {e!s}")

	def _add_threat_intel(self, **kwargs) -> None:
		"""Add or update threat intelligence entry."""
		threat_intel = ThreatIntelligence(**kwargs)
		if threat_intel.confidence_score >= MIN_CONFIDENCE_SCORE:
			self.known_threats[threat_intel.hash] = threat_intel

	async def check_hash(self, file_hash: str) -> Optional[ThreatIntelligence]:
		"""Check if a hash is known to be malicious."""
		# First check local cache
		if file_hash in self.known_threats:
			return self.known_threats[file_hash]

		# Update threat intelligence if needed
		await self.update_threat_intelligence()

		# Check again after update
		return self.known_threats.get(file_hash)


class MalwareScanner:
	"""Enhanced malware scanner with dynamic threat intelligence."""

	# Static patterns for initial detection
	SUSPICIOUS_PATTERNS: ClassVar[List[bytes]] = [
		# Code execution
		b"eval(",
		b"exec(",
		b"execfile(",
		b"compile(",
		# System commands
		b"os.system",
		b"os.popen",
		b"subprocess.run",
		b"subprocess.Popen",
		b"subprocess.call",
		b"pty.spawn",
		# Dynamic imports
		b"__import__",
		b"importlib",
		b"imp.load_source",
		# Encoding/Encryption
		b"base64.b64decode",
		b"base64.b64encode",
		b"codecs.encode",
		b"codecs.decode",
		b"zlib.decompress",
		# Network
		b"socket.connect",
		b"urllib.request",
		b"requests.post",
		b"requests.get",
		b"http.client",
		# File operations
		b"open(",
		b"file.write",
		b"tempfile.mktemp",
		# Process manipulation
		b"os.fork",
		b"multiprocessing",
		b"threading.Thread",
		# Common malware strings
		b"shell",
		b"backdoor",
		b"rootkit",
		b"RAT",
		b"keylog",
		b"botnet",
	]

	def __init__(self):
		"""Initialize malware scanner with threat intelligence."""
		self.threat_manager = ThreatIntelligenceManager()
		self.initialization_lock = asyncio.Lock()
		self.initialized = False
		self.last_patterns_update = datetime.min
		self.dynamic_patterns: List[bytes] = []
		self.pattern_update_interval = timedelta(hours=1)

	async def ensure_initialized(self) -> None:
		"""Ensure the scanner is initialized."""
		if self.initialized:
			return

		async with self.initialization_lock:
			if not self.initialized:
				await self.threat_manager.initialize()
				await self.update_dynamic_patterns()
				self.initialized = True

	async def update_dynamic_patterns(self) -> None:
		"""Update dynamic malware patterns from threat intelligence."""
		if (datetime.now() - self.last_patterns_update).total_seconds() < THREAT_UPDATE_INTERVAL:
			return

		try:
			# Get latest patterns from threat intelligence
			patterns = await cache_manager.async_get("malware_patterns")
			if patterns:
				self.dynamic_patterns = patterns
			else:
				# Update patterns from threat intelligence feeds
				self.dynamic_patterns = await self._fetch_latest_patterns()
				await cache_manager.async_set("malware_patterns", self.dynamic_patterns, THREAT_INTEL_CACHE_TTL)

			self.last_patterns_update = datetime.now()

		except Exception as e:
			logger.error(f"Error updating dynamic patterns: {e!s}")

	async def _fetch_latest_patterns(self) -> List[bytes]:
		"""Fetch latest malware patterns from threat intelligence sources."""
		patterns = []
		async with aiohttp.ClientSession() as session:
			# Fetch from ThreatFox
			if self.threat_manager.api_keys["threatfox"]:
				try:
					url = "https://threatfox-api.abuse.ch/api/v1/"
					data = {"query": "get_ioc", "days": 1}
					async with session.post(url, json=data) as response:
						if response.status == 200:
							data = await response.json()
							for ioc in data.get("data", []):
								if ioc.get("ioc_type") == "yara_rule":
									pattern = ioc.get("ioc")
									if pattern:
										patterns.append(pattern.encode())
				except Exception as e:
					logger.error(f"Error fetching ThreatFox patterns: {e!s}")

			# Fetch from AlienVault OTX
			if self.threat_manager.api_keys["alienvault"]:
				try:
					url = "https://otx.alienvault.com/api/v1/pulses/subscribed"
					headers = {"X-OTX-API-KEY": self.threat_manager.api_keys["alienvault"]}
					async with session.get(url, headers=headers) as response:
						if response.status == 200:
							data = await response.json()
							for pulse in data.get("results", []):
								if "malware" in pulse.get("tags", []):
									for indicator in pulse.get("indicators", []):
										if indicator.get("type") == "YARA":
											pattern = indicator.get("content")
											if pattern:
												patterns.append(pattern.encode())
				except Exception as e:
					logger.error(f"Error fetching AlienVault patterns: {e!s}")

		return patterns

	async def scan_file(self, file_path: Union[str, Path], scan_type: str = "full") -> ScanResult:
		"""
		Enhanced scan of file for malware using dynamic threat intelligence.

		Args:
		    file_path: Path to file to scan
		    scan_type: Type of scan to perform ("quick" or "full")

		Returns:
		    ScanResult with scan details and threat intelligence
		"""
		start_time = time.time()
		file_path = Path(file_path)

		try:
			# Ensure initialized
			await self.ensure_initialized()

			# Calculate file hash
			file_hash = self._calculate_file_hash(file_path)

			# Check against known threats
			threat_intel = await self.threat_manager.check_hash(file_hash)
			if threat_intel:
				return ScanResult(
					status=ScanStatus.INFECTED,
					threats_found=[threat_intel.threat_type],
					scan_engine="threat_intelligence",
					scan_time_seconds=time.time() - start_time,
					file_hash=file_hash,
					threat_intel=threat_intel,
					metadata={"confidence": threat_intel.confidence_score, "source": threat_intel.source},
				)

			# Update dynamic patterns
			await self.update_dynamic_patterns()

			# Combine static and dynamic patterns
			all_patterns = self.SUSPICIOUS_PATTERNS + self.dynamic_patterns

			# Perform pattern matching
			with open(file_path, "rb") as f:
				content = f.read()
				threats = []

				# Quick scan checks only the first 8KB
				scan_content = content[:8192] if scan_type == "quick" else content

				for pattern in all_patterns:
					if pattern in scan_content:
						threats.append(f"Suspicious pattern: {pattern[:32]}")

			# Determine scan status
			if threats:
				status = ScanStatus.SUSPICIOUS
			else:
				status = ScanStatus.CLEAN

			return ScanResult(
				status=status,
				threats_found=threats,
				scan_engine="enhanced_pattern_matching",
				scan_time_seconds=time.time() - start_time,
				file_hash=file_hash,
				metadata={"scan_type": scan_type, "file_size": file_path.stat().st_size, "patterns_version": self.last_patterns_update.isoformat()},
			)

		except Exception as e:
			logger.error(f"Error scanning file {file_path}: {e!s}")
			return ScanResult(
				status=ScanStatus.ERROR,
				threats_found=[str(e)],
				scan_engine="error",
				scan_time_seconds=time.time() - start_time,
				file_hash="",
				metadata={"error": str(e)},
			)

	def _calculate_file_hash(self, file_path: Path) -> str:
		"""Calculate SHA-256 hash of file."""
		sha256_hash = hashlib.sha256()
		with open(file_path, "rb") as f:
			for byte_block in iter(lambda: f.read(4096), b""):
				sha256_hash.update(byte_block)
		return sha256_hash.hexdigest()

	# Base suspicious file patterns (enhanced by dynamic patterns)
	SUSPICIOUS_PATTERNS: ClassVar[List[bytes]] = [
		# Executable patterns
		b"MZ",  # PE executable header
		b"\x7fELF",  # ELF executable header
		b"\xca\xfe\xba\xbe",  # Mach-O executable header
		b"\xfe\xed\xfa\xce",  # Mach-O 32-bit
		b"\xce\xfa\xed\xfe",  # Mach-O 32-bit reverse
		# Script patterns
		b"#!/bin/sh",
		b"#!/bin/bash",
		b"#!/usr/bin/env",
		b"@echo off",
		b"powershell",
		b"cmd.exe",
		b"wscript",
		b"cscript",
		# Suspicious strings
		b"eval(",
		b"exec(",
		b"system(",
		b"shell_exec(",
		b"passthru(",
		b"base64_decode(",
		b"CreateObject(",
		b"WScript.Shell",
		b"ActiveXObject",
		# Network patterns
		b"http://",
		b"https://",
		b"ftp://",
		b"tcp://",
		b"udp://",
		b"socket(",
		b"connect(",
		b"bind(",
		b"listen(",
		# Crypto/encoding patterns
		b"base64",
		b"atob(",
		b"btoa(",
		b"unescape(",
		b"decodeURIComponent(",
		# Registry manipulation (Windows)
		b"RegOpenKey",
		b"RegSetValue",
		b"RegDeleteKey",
		b"HKEY_LOCAL_MACHINE",
		b"HKEY_CURRENT_USER",
		# Process injection patterns
		b"VirtualAlloc",
		b"WriteProcessMemory",
		b"CreateRemoteThread",
		b"NtCreateThreadEx",
		b"RtlCreateUserThread",
		# File operations
		b"CreateFile",
		b"WriteFile",
		b"DeleteFile",
		b"MoveFile",
		# Network evasion
		b"WSASocket",
		b"connect",
		b"recv",
		b"send",
		b"bind",
		# Command execution
		b"WinExec",
		b"ShellExecute",
		b"CreateProcess",
		b"system(",
		# Encryption operations
		b"CryptoAPI",
		b"BCrypt",
		b"NCrypt",
		b"OpenSSLHKEY_",
		b"RegWrite",
		b"RegRead",
		b"RegDelete",
		# File system manipulation
		b"CreateFile",
		b"WriteFile",
		b"DeleteFile",
		b"MoveFile",
		b"CopyFile",
		# Process manipulation
		b"CreateProcess",
		b"TerminateProcess",
		b"OpenProcess",
		b"VirtualAlloc",
		b"VirtualProtect",
		# Anti-analysis techniques
		b"IsDebuggerPresent",
		b"CheckRemoteDebuggerPresent",
		b"GetTickCount",
		b"Sleep(",
		b"delay(",
		# Persistence mechanisms
		b"autorun",
		b"startup",
		b"scheduled task",
		b"service install",
		b"registry run",
	]

	def __init__(self):
		"""Initialize malware scanner."""
		self.clamav_available = self._check_clamav_availability()

	def _check_clamav_availability(self) -> bool:
		"""Check if ClamAV is available."""
		try:
			result = subprocess.run(["clamscan", "--version"], capture_output=True, text=True, timeout=5)
			return result.returncode == 0
		except (subprocess.TimeoutExpired, FileNotFoundError, subprocess.SubprocessError):
			logger.warning("ClamAV not available, using built-in scanning only")
			return False

	async def scan_file(self, file_content: bytes, filename: str) -> ScanResult:
		"""
		Scan file for malware using available engines.

		Args:
		    file_content: Raw file content
		    filename: Original filename

		Returns:
		    ScanResult with scan details
		"""
		import time

		start_time = time.time()

		logger.info(f"Starting malware scan for file: {filename}")

		# Generate file hash
		file_hash = hashlib.sha256(file_content).hexdigest()

		# Initialize result
		result = ScanResult(
			status=ScanStatus.CLEAN,
			threats_found=[],
			scan_engine="built-in",
			scan_time_seconds=0.0,
			file_hash=file_hash,
			metadata={"filename": filename, "file_size": len(file_content)},
		)

		try:
			# Check against known malicious hashes
			hash_threats = self._check_malicious_hashes(file_hash)
			if hash_threats:
				result.threats_found.extend(hash_threats)
				result.status = ScanStatus.INFECTED

			# Pattern-based scanning
			pattern_threats = self._scan_patterns(file_content)
			if pattern_threats:
				result.threats_found.extend(pattern_threats)
				if result.status == ScanStatus.CLEAN:
					result.status = ScanStatus.SUSPICIOUS

			# Heuristic analysis
			heuristic_threats = self._heuristic_analysis(file_content, filename)
			if heuristic_threats:
				result.threats_found.extend(heuristic_threats)
				if result.status == ScanStatus.CLEAN:
					result.status = ScanStatus.SUSPICIOUS

			# ClamAV scanning if available
			if self.clamav_available:
				clamav_result = await self._scan_with_clamav(file_content, filename)
				if clamav_result.status != ScanStatus.CLEAN:
					result.threats_found.extend(clamav_result.threats_found)
					result.status = clamav_result.status
					result.scan_engine = "clamav+built-in"

			# Calculate scan time
			result.scan_time_seconds = time.time() - start_time

			# Record malware scan metrics
			metrics_collector.record_malware_scan(result=result.status.value, engine=result.scan_engine)

			# Record security events if threats found
			if result.threats_found:
				severity = "high" if result.status == ScanStatus.INFECTED else "medium"
				metrics_collector.record_security_event(event_type="malware_detected", severity=severity)

			logger.info(f"Malware scan completed for {filename}: {result.status.value}")
			return result

		except Exception as e:
			logger.error(f"Error during malware scan: {e}", exc_info=True)
			result.status = ScanStatus.ERROR
			result.threats_found.append(f"Scan error: {e!s}")
			result.scan_time_seconds = time.time() - start_time

			# Record failed scan metrics
			metrics_collector.record_malware_scan(result="error", engine="built-in")

			metrics_collector.record_security_event(event_type="scan_error", severity="medium")

			return result

	def _check_malicious_hashes(self, file_hash: str) -> List[str]:
		"""Check file hash against known malicious hashes."""
		threats = []

		if file_hash in self.KNOWN_MALICIOUS_HASHES:
			threats.append(f"Known malicious file hash: {file_hash}")

		return threats

	def _scan_patterns(self, file_content: bytes) -> List[str]:
		"""Scan for suspicious patterns in file content."""
		threats = []

		# Convert to lowercase for case-insensitive matching
		content_lower = file_content.lower()

		for pattern in self.SUSPICIOUS_PATTERNS:
			if pattern in content_lower:
				threats.append(f"Suspicious pattern detected: {pattern.decode('utf-8', errors='ignore')}")

		return threats

	def _heuristic_analysis(self, file_content: bytes, filename: str) -> List[str]:
		"""Perform heuristic analysis for suspicious behavior."""
		threats = []

		# Check entropy (high entropy might indicate encryption/packing)
		entropy = self._calculate_entropy(file_content)
		if entropy > 7.5:  # High entropy threshold
			threats.append(f"High entropy detected: {entropy:.2f} (possible packed/encrypted content)")

		# Check for excessive repetition (possible padding attack)
		if self._has_excessive_repetition(file_content):
			threats.append("Excessive repetition detected (possible padding attack)")

		# Check for suspicious file size patterns
		file_size = len(file_content)
		if file_size == 0:
			threats.append("Empty file detected")
		elif file_size > 100 * 1024 * 1024:  # 100MB
			threats.append(f"Unusually large file: {file_size} bytes")

		# Check for embedded executables
		if self._has_embedded_executable(file_content):
			threats.append("Embedded executable detected")

		# Check for suspicious metadata
		if self._has_suspicious_metadata(filename):
			threats.append("Suspicious filename patterns detected")

		# Advanced behavioral analysis
		advanced_threats = self._advanced_behavioral_analysis(file_content, filename)
		threats.extend(advanced_threats)

		return threats

	def _advanced_behavioral_analysis(self, file_content: bytes, filename: str) -> List[str]:
		"""Perform advanced behavioral analysis using YARA-like rules."""
		threats = []

		# Check for polyglot files (files that are valid in multiple formats)
		if self._is_polyglot_file(file_content):
			threats.append("Polyglot file detected (valid in multiple formats)")

		# Check for steganography indicators
		if self._has_steganography_indicators(file_content):
			threats.append("Possible steganography detected")

		# Check for code injection patterns
		injection_patterns = self._detect_code_injection_patterns(file_content)
		threats.extend(injection_patterns)

		# Check for anti-VM/sandbox techniques
		if self._has_anti_analysis_techniques(file_content):
			threats.append("Anti-analysis techniques detected")

		# Check for persistence mechanisms
		persistence_threats = self._detect_persistence_mechanisms(file_content)
		threats.extend(persistence_threats)

		# Check for data exfiltration patterns
		exfiltration_threats = self._detect_exfiltration_patterns(file_content)
		threats.extend(exfiltration_threats)

		# Check for lateral movement indicators
		if self._has_lateral_movement_indicators(file_content):
			threats.append("Lateral movement techniques detected")

		return threats

	def _is_polyglot_file(self, file_content: bytes) -> bool:
		"""Check if file is a polyglot (valid in multiple formats)."""
		if len(file_content) < 100:
			return False

		# Check for multiple file format headers
		headers_found = 0

		# Common file headers
		file_headers = [
			b"%PDF-",  # PDF
			b"PK\x03\x04",  # ZIP/Office
			b"\xff\xd8\xff",  # JPEG
			b"\x89PNG",  # PNG
			b"GIF8",  # GIF
			b"MZ",  # PE executable
			b"\x7fELF",  # ELF
			b"<!DOCTYPE",  # HTML
			b"<html",  # HTML
			b"<?xml",  # XML
		]

		for header in file_headers:
			if header in file_content:
				headers_found += 1

		return headers_found >= 2

	def _has_steganography_indicators(self, file_content: bytes) -> bool:
		"""Check for steganography indicators."""
		# Look for unusual patterns in image-like files
		if len(file_content) < 1000:
			return False

		# Check for hidden data patterns
		# Look for LSB steganography indicators
		if b"\xff\xd8\xff" in file_content[:10]:  # JPEG
			# Check for unusual comment sections
			if b"\xff\xfe" in file_content:  # Comment marker
				return True

		# Check for unusual entropy distribution
		chunks = [file_content[i : i + 1024] for i in range(0, len(file_content), 1024)]
		entropies = [self._calculate_entropy(chunk) for chunk in chunks if len(chunk) > 100]

		if len(entropies) > 5:
			entropy_variance = sum((e - sum(entropies) / len(entropies)) ** 2 for e in entropies) / len(entropies)
			if entropy_variance > 2.0:  # High variance in entropy
				return True

		return False

	def _detect_code_injection_patterns(self, file_content: bytes) -> List[str]:
		"""Detect code injection patterns."""
		threats = []

		# DLL injection patterns
		dll_injection_patterns = [
			b"LoadLibrary",
			b"GetProcAddress",
			b"VirtualAllocEx",
			b"WriteProcessMemory",
			b"CreateRemoteThread",
			b"SetWindowsHookEx",
		]

		dll_pattern_count = sum(1 for pattern in dll_injection_patterns if pattern in file_content)
		if dll_pattern_count >= 3:
			threats.append(f"DLL injection patterns detected ({dll_pattern_count} indicators)")

		# Process hollowing patterns
		hollowing_patterns = [
			b"NtUnmapViewOfSection",
			b"VirtualAllocEx",
			b"WriteProcessMemory",
			b"SetThreadContext",
			b"ResumeThread",
		]

		hollowing_pattern_count = sum(1 for pattern in hollowing_patterns if pattern in file_content)
		if hollowing_pattern_count >= 3:
			threats.append(f"Process hollowing patterns detected ({hollowing_pattern_count} indicators)")

		# Reflective DLL loading
		if b"ReflectiveLoader" in file_content or (b"DllMain" in file_content and b"GetProcAddress" in file_content):
			threats.append("Reflective DLL loading patterns detected")

		return threats

	def _has_anti_analysis_techniques(self, file_content: bytes) -> bool:
		"""Check for anti-analysis techniques."""
		anti_analysis_patterns = [
			b"IsDebuggerPresent",
			b"CheckRemoteDebuggerPresent",
			b"NtQueryInformationProcess",
			b"OutputDebugString",
			b"GetTickCount",
			b"QueryPerformanceCounter",
			b"cpuid",
			b"rdtsc",
			b"VirtualBox",
			b"VMware",
			b"QEMU",
			b"Xen",
			b"Sandbox",
			b"Cuckoo",
			b"Anubis",
		]

		pattern_count = sum(1 for pattern in anti_analysis_patterns if pattern in file_content)
		return pattern_count >= 2

	def _detect_persistence_mechanisms(self, file_content: bytes) -> List[str]:
		"""Detect persistence mechanisms."""
		threats = []

		# Registry persistence
		registry_patterns = [
			b"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
			b"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
			b"SYSTEM\\CurrentControlSet\\Services",
			b"RegSetValueEx",
			b"RegCreateKeyEx",
		]

		registry_count = sum(1 for pattern in registry_patterns if pattern in file_content)
		if registry_count >= 2:
			threats.append(f"Registry persistence mechanisms detected ({registry_count} indicators)")

		# File system persistence
		if b"autorun.inf" in file_content or b"desktop.ini" in file_content:
			threats.append("File system persistence mechanisms detected")

		# Service persistence
		service_patterns = [b"CreateService", b"OpenSCManager", b"StartService"]
		service_count = sum(1 for pattern in service_patterns if pattern in file_content)
		if service_count >= 2:
			threats.append("Service persistence mechanisms detected")

		# Scheduled task persistence
		if b"schtasks" in file_content or b"Task Scheduler" in file_content:
			threats.append("Scheduled task persistence detected")

		return threats

	def _detect_exfiltration_patterns(self, file_content: bytes) -> List[str]:
		"""Detect data exfiltration patterns."""
		threats = []

		# Network exfiltration
		network_patterns = [
			b"HttpSendRequest",
			b"InternetOpen",
			b"URLDownloadToFile",
			b"WinHttpOpen",
			b"send(",
			b"recv(",
			b"FTP",
			b"SMTP",
		]

		network_count = sum(1 for pattern in network_patterns if pattern in file_content)
		if network_count >= 3:
			threats.append(f"Network exfiltration patterns detected ({network_count} indicators)")

		# File exfiltration
		file_patterns = [
			b"CopyFile",
			b"MoveFile",
			b"CreateFile",
			b"WriteFile",
			b"ReadFile",
		]

		file_count = sum(1 for pattern in file_patterns if pattern in file_content)
		if file_count >= 4:
			threats.append("File manipulation patterns detected")

		# Encryption before exfiltration
		crypto_patterns = [
			b"CryptAcquireContext",
			b"CryptEncrypt",
			b"CryptCreateHash",
			b"AES",
			b"RSA",
			b"base64",
		]

		crypto_count = sum(1 for pattern in crypto_patterns if pattern in file_content)
		if crypto_count >= 2 and network_count >= 1:
			threats.append("Encrypted data exfiltration patterns detected")

		return threats

	def _has_lateral_movement_indicators(self, file_content: bytes) -> bool:
		"""Check for lateral movement indicators."""
		lateral_patterns = [
			b"PsExec",
			b"WMI",
			b"WinRM",
			b"PowerShell",
			b"net use",
			b"net share",
			b"SMB",
			b"RDP",
			b"SSH",
			b"Telnet",
			b"NetUserEnum",
			b"NetShareEnum",
			b"NetSessionEnum",
		]

		pattern_count = sum(1 for pattern in lateral_patterns if pattern in file_content)
		return pattern_count >= 3

	def _calculate_entropy(self, data: bytes) -> float:
		"""Calculate Shannon entropy of data."""
		if not data:
			return 0.0

		# Count byte frequencies
		byte_counts = [0] * 256
		for byte in data:
			byte_counts[byte] += 1

		# Calculate entropy
		entropy = 0.0
		data_len = len(data)

		for count in byte_counts:
			if count > 0:
				probability = count / data_len
				entropy -= probability * math.log2(probability)

		return entropy

	def _has_excessive_repetition(self, file_content: bytes) -> bool:
		"""Check for excessive repetition in file content."""
		if len(file_content) < 1000:
			return False

		# Check for repeated patterns
		sample_size = min(1000, len(file_content))
		sample = file_content[:sample_size]

		# Count most common byte
		byte_counts = {}
		for byte in sample:
			byte_counts[byte] = byte_counts.get(byte, 0) + 1

		max_count = max(byte_counts.values())
		repetition_ratio = max_count / sample_size

		return repetition_ratio > 0.8  # 80% repetition threshold

	def _has_embedded_executable(self, file_content: bytes) -> bool:
		"""Check for embedded executable content."""
		# Look for executable headers within the file
		executable_headers = [b"MZ", b"\x7fELF", b"\xca\xfe\xba\xbe"]

		for header in executable_headers:
			# Check if header appears not at the beginning (embedded)
			pos = file_content.find(header, 100)  # Skip first 100 bytes
			if pos != -1:
				return True

		return False

	def _has_suspicious_metadata(self, filename: str) -> bool:
		"""Check for suspicious filename patterns."""
		suspicious_patterns = [
			"temp",
			"tmp",
			"cache",
			"system32",
			"windows",
			"program files",
			"autorun",
			"setup",
			"install",
			"update",
			"patch",
			"crack",
			"keygen",
			"serial",
			"license",
			"activation",
		]

		filename_lower = filename.lower()
		return any(pattern in filename_lower for pattern in suspicious_patterns)

	async def _scan_with_clamav(self, file_content: bytes, filename: str) -> ScanResult:
		"""Scan file using ClamAV engine."""
		result = ScanResult(
			status=ScanStatus.CLEAN,
			threats_found=[],
			scan_engine="clamav",
			scan_time_seconds=0.0,
			file_hash=hashlib.sha256(file_content).hexdigest(),
			metadata={"filename": filename},
		)

		if not self.clamav_available:
			result.status = ScanStatus.SKIPPED
			return result

		import time

		start_time = time.time()

		try:
			# Write file to temporary location for scanning
			with tempfile.NamedTemporaryFile(delete=False) as temp_file:
				temp_file.write(file_content)
				temp_file_path = temp_file.name

			try:
				# Run ClamAV scan
				cmd = ["clamscan", "--no-summary", "--infected", temp_file_path]
				process = subprocess.run(
					cmd,
					capture_output=True,
					text=True,
					timeout=30,  # 30 second timeout
				)

				result.scan_time_seconds = time.time() - start_time

				if process.returncode == 0:
					# Clean file
					result.status = ScanStatus.CLEAN
				elif process.returncode == 1:
					# Infected file
					result.status = ScanStatus.INFECTED
					# Parse threats from output
					for line in process.stdout.split("\n"):
						if "FOUND" in line:
							threat = line.split(":")[-1].strip()
							result.threats_found.append(f"ClamAV: {threat}")
				else:
					# Error occurred
					result.status = ScanStatus.ERROR
					result.threats_found.append(f"ClamAV scan error: {process.stderr}")

			finally:
				# Clean up temporary file
				Path(temp_file_path).unlink(missing_ok=True)

		except subprocess.TimeoutExpired:
			result.status = ScanStatus.ERROR
			result.threats_found.append("ClamAV scan timeout")
			result.scan_time_seconds = time.time() - start_time
		except Exception as e:
			result.status = ScanStatus.ERROR
			result.threats_found.append(f"ClamAV scan error: {e!s}")
			result.scan_time_seconds = time.time() - start_time

		return result

	def update_threat_database(self) -> bool:
		"""Update malware threat database."""
		success = True

		# Update ClamAV database if available
		if self.clamav_available:
			try:
				result = subprocess.run(
					["freshclam"],
					capture_output=True,
					text=True,
					timeout=300,  # 5 minute timeout
				)

				if result.returncode == 0:
					logger.info("ClamAV database updated successfully")
				else:
					logger.error(f"Failed to update ClamAV database: {result.stderr}")
					success = False

			except Exception as e:
				logger.error(f"Error updating ClamAV database: {e}")
				success = False
		else:
			logger.warning("ClamAV not available, skipping ClamAV database update")

		# Update built-in threat intelligence
		try:
			self._update_threat_intelligence()
			logger.info("Built-in threat intelligence updated successfully")
		except Exception as e:
			logger.error(f"Error updating threat intelligence: {e}")
			success = False

		return success

	def _update_threat_intelligence(self) -> None:
		"""Update built-in threat intelligence from various sources."""
		# In a production environment, this would fetch from threat intelligence feeds
		# For now, we'll update our known malicious hashes with common test hashes

		# EICAR test file hash (standard antivirus test file)
		eicar_hash = "275a021bbfb6489e54d471899f7db9d1663fc695ec2fe2a2c4538aabf651fd0f"

		# Add to known malicious hashes
		self.KNOWN_MALICIOUS_HASHES.add(eicar_hash)

		# Update suspicious patterns with latest IOCs (Indicators of Compromise)
		new_patterns = [
			# Recent malware families
			b"Emotet",
			b"TrickBot",
			b"Ryuk",
			b"Conti",
			b"Maze",
			b"REvil",
			b"DarkSide",
			b"BlackMatter",
			# APT indicators
			b"Cobalt Strike",
			b"Metasploit",
			b"Empire",
			b"PowerSploit",
			# Cryptocurrency miners
			b"xmrig",
			b"cpuminer",
			b"ccminer",
			b"ethminer",
			# Remote access tools
			b"TeamViewer",
			b"AnyDesk",
			b"Chrome Remote Desktop",
			b"LogMeIn",
			# Suspicious domains (simplified check)
			b".tk",
			b".ml",
			b".ga",
			b".cf",
			b"bit.ly",
			b"tinyurl",
			b"t.co",
		]

		# Add new patterns to existing ones
		self.SUSPICIOUS_PATTERNS.extend(new_patterns)

		logger.info(f"Updated threat intelligence with {len(new_patterns)} new patterns")

	def get_threat_intelligence_info(self) -> Dict[str, any]:
		"""Get information about current threat intelligence."""
		return {
			"known_malicious_hashes": len(self.KNOWN_MALICIOUS_HASHES),
			"suspicious_patterns": len(self.SUSPICIOUS_PATTERNS),
			"last_updated": "manual_update",  # In production, track actual update times
			"sources": ["built-in", "clamav" if self.clamav_available else None],
			"version": "1.0.0",
		}

	def get_scanner_info(self) -> Dict[str, any]:
		"""Get information about available scanners."""
		info = {"built_in_scanner": True, "clamav_available": self.clamav_available, "supported_engines": ["built-in"]}

		if self.clamav_available:
			info["supported_engines"].append("clamav")

			try:
				# Get ClamAV version
				result = subprocess.run(["clamscan", "--version"], capture_output=True, text=True, timeout=5)
				if result.returncode == 0:
					info["clamav_version"] = result.stdout.strip()
			except Exception:
				pass

		return info
		return info
