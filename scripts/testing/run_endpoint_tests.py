#!/usr/bin/env python3
"""
Simple endpoint test runner using FastAPI TestClient.

Loads the static endpoint map generated by `discover_endpoints.py` and
executes simple requests against the app created by `app.main.create_app()`.

Outputs a JSON report to `reports/endpoint_test_results.json` and prints
a short summary. This is intended as a pragmatic automated test when the
full integration environment is not available.
"""

import asyncio
import json
import time
from pathlib import Path

from httpx import ASGITransport, AsyncClient

ROOT = Path(__file__).resolve().parents[2]
REPORTS = ROOT / "reports"
ENDPOINT_MAP = REPORTS / "endpoint_map.json"
OUTPUT = REPORTS / "endpoint_test_results.json"


def load_app():
	# Ensure the backend package directory is on sys.path and import the
	# application package by its canonical name ("app") so SQLAlchemy model
	# classes are registered under a single module path. This avoids the
	# "Multiple classes found for path ..." mapper duplication caused when
	# modules are imported under both 'backend.app' and 'app'.
	root = Path(__file__).resolve().parents[2]
	backend_dir = root / "backend"
	import sys

	if str(backend_dir) not in sys.path:
		sys.path.insert(0, str(backend_dir))

	# import here to avoid side effects during static analysis
	from app.main import create_app

	return create_app()


def run_tests():
	if not ENDPOINT_MAP.exists():
		print(f"Endpoint map not found: {ENDPOINT_MAP}. Run discover_endpoints.py first.")
		return 2

	with open(ENDPOINT_MAP, encoding="utf-8") as f:
		endpoints = json.load(f)

	# Use an in-process async HTTP client bound to the same event loop as
	# the application to avoid cross-event-loop asyncpg issues in tests.

	app = load_app()

	results = []

	async def _run():
		transport = ASGITransport(app=app)
		async with AsyncClient(transport=transport, base_url="http://testserver") as client:
			for ep in endpoints:
				method = ep["method"].upper()
				path = ep["path"]

				data = None
				headers = {"accept": "application/json"}
				if method in ("POST", "PUT", "PATCH"):
					data = {}

				start = time.time()
				try:
					r = await client.request(method, path, json=data if data is not None else None, headers=headers)
					elapsed = time.time() - start
					results.append(
						{
							"method": method,
							"path": path,
							"status": "ok" if r.status_code < 500 else "error",
							"status_code": r.status_code,
							"response_time": round(elapsed, 4),
							"body_snippet": r.text[:200],
						}
					)
				except Exception as e:
					elapsed = time.time() - start
					results.append(
						{
							"method": method,
							"path": path,
							"status": "error",
							"status_code": None,
							"response_time": round(elapsed, 4),
							"error": str(e),
						}
					)

	# Run the async runner
	asyncio.run(_run())

	REPORTS.mkdir(parents=True, exist_ok=True)
	with open(OUTPUT, "w", encoding="utf-8") as f:
		json.dump({"generated_at": time.time(), "results": results}, f, indent=2)

	# Print summary
	total = len(results)
	passed = sum(1 for r in results if r.get("status_code") and 200 <= r["status_code"] < 400)
	auth_errors = sum(1 for r in results if r.get("status_code") in (401, 403))
	server_errors = sum(1 for r in results if r.get("status_code") and r["status_code"] >= 500)

	print(f"Ran {total} endpoint checks")
	print(f"  2xx-3xx successes: {passed}")
	print(f"  auth failures (401/403): {auth_errors}")
	print(f"  server errors (5xx): {server_errors}")
	print(f"Report written to: {OUTPUT}")

	return 0


if __name__ == "__main__":
	raise SystemExit(run_tests())
